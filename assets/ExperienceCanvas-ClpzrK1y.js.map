{"version":3,"file":"ExperienceCanvas-ClpzrK1y.js","sources":["../../node_modules/three-stdlib/_polyfill/uv1.js","../../node_modules/three-stdlib/node_modules/fflate/esm/browser.js","../../node_modules/three-stdlib/curves/NURBSUtils.js","../../node_modules/three-stdlib/curves/NURBSCurve.js","../../node_modules/three-stdlib/loaders/FBXLoader.js","../../node_modules/@react-three/drei/core/Fbx.js","../../node_modules/@react-three/drei/core/useAnimations.js","../../src/components/experience/ExperienceCanvas.jsx"],"sourcesContent":["import { version } from \"./constants.js\";\nconst UV1 = version >= 125 ? \"uv1\" : \"uv2\";\nexport {\n  UV1\n};\n//# sourceMappingURL=uv1.js.map\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([c], { type: 'text/javascript' }))));\n    w.onerror = function (e) { return cb(e.error, null); };\n    w.onmessage = function (e) { return cb(null, e.data); };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i)\n        ++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p / 8) | 0) + (p & 7 && 1); };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && !st.l && sl < 5))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                throw 'invalid block type';\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n            if (!c)\n                throw 'invalid length/literal';\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    throw 'invalid distance';\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            }\n            else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (t)\n            throw 'stream finished';\n        if (!strm.ondata)\n            throw 'no stream handler';\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        throw 'invalid gzip data';\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        throw 'invalid zlib data';\n    if (d[1] & 32)\n        throw 'invalid zlib data: preset dictionaries not supported';\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                throw 'invalid gzip stream';\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                throw 'invalid zlib stream';\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no stream handler';\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k;\n        if (val instanceof u8)\n            t[n] = [val, o];\n        else if (Array.isArray(val))\n            t[n] = [val[0], mrg(o, val[1])];\n        else\n            fltn(val, n + '/', t, o);\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    throw 'invalid utf-8 data';\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            throw 'stream finished';\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                throw 'invalid utf-8 data';\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        if (this.d)\n            throw 'stream finished';\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            throw 'invalid utf-8 data';\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                throw 'extra field too long';\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c == null && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        throw 'date not in range 1980-2099';\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != null) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback - add to ZIP archive before pushing';\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (this.d & 2)\n            throw 'stream finished';\n        var f = strToU8(file.filename), fl = f.length;\n        var com = file.comment, o = com && strToU8(com);\n        var u = fl != file.filename.length || (o && (com.length != o.length));\n        var hl = fl + exfl(file.extra) + 30;\n        if (fl > 65535)\n            throw 'filename too long';\n        var header = new u8(hl);\n        wzh(header, 0, file, f, u);\n        var chks = [header];\n        var pAll = function () {\n            for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {\n                var chk = chks_1[_i];\n                _this_1.ondata(null, chk, false);\n            }\n            chks = [];\n        };\n        var tr = this.d;\n        this.d = 0;\n        var ind = this.u.length;\n        var uf = mrg(file, {\n            f: f,\n            u: u,\n            o: o,\n            t: function () {\n                if (file.terminate)\n                    file.terminate();\n            },\n            r: function () {\n                pAll();\n                if (tr) {\n                    var nxt = _this_1.u[ind + 1];\n                    if (nxt)\n                        nxt.r();\n                    else\n                        _this_1.d = 1;\n                }\n                tr = 1;\n            }\n        });\n        var cl = 0;\n        file.ondata = function (err, dat, final) {\n            if (err) {\n                _this_1.ondata(err, dat, final);\n                _this_1.terminate();\n            }\n            else {\n                cl += dat.length;\n                chks.push(dat);\n                if (final) {\n                    var dd = new u8(16);\n                    wbytes(dd, 0, 0x8074B50);\n                    wbytes(dd, 4, file.crc);\n                    wbytes(dd, 8, cl);\n                    wbytes(dd, 12, file.size);\n                    chks.push(dd);\n                    uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n                    if (tr)\n                        uf.r();\n                    tr = 1;\n                }\n                else if (tr)\n                    pAll();\n            }\n        };\n        this.u.push(uf);\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            if (this.d & 1)\n                throw 'stream finishing';\n            throw 'stream finished';\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl('filename too long', null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            throw 'filename too long';\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, data, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            throw 'no callback';\n        if (!this.p)\n            throw 'stream finished';\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_2 = [];\n                        this_1.k.unshift(chks_2);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    throw 'no callback';\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        throw 'unknown compression type ' + cmp_1;\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {\n                                        var dat = chks_3[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_2 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                throw 'invalid zip file';\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */\nexport function unzip(data, cb) {\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cb('invalid zip file', null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft)\n        cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) {\n            cb('invalid zip file', null);\n            return;\n        }\n        c = lft = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    var _loop_3 = function (i) {\n        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                files[fn] = d;\n                if (!--lft)\n                    cb(null, files);\n            }\n        };\n        if (!c_1)\n            cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                }\n                catch (e) {\n                    cbl(e, null);\n                }\n            }\n            else\n                term.push(inflate(infl, { size: su }, cbl));\n        }\n        else\n            cbl('unknown compression type ' + c_1, null);\n    };\n    for (var i = 0; i < c; ++i) {\n        _loop_3(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */\nexport function unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            throw 'invalid zip file';\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50)\n            throw 'invalid zip file';\n        c = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2)\n            files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8)\n            files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else\n            throw 'unknown compression type ' + c_2;\n    }\n    return files;\n}\n","import { Vector4, Vector3 } from \"three\";\nfunction findSpan(p, u, U) {\n  const n = U.length - p - 1;\n  if (u >= U[n]) {\n    return n - 1;\n  }\n  if (u <= U[p]) {\n    return p;\n  }\n  let low = p;\n  let high = n;\n  let mid = Math.floor((low + high) / 2);\n  while (u < U[mid] || u >= U[mid + 1]) {\n    if (u < U[mid]) {\n      high = mid;\n    } else {\n      low = mid;\n    }\n    mid = Math.floor((low + high) / 2);\n  }\n  return mid;\n}\nfunction calcBasisFunctions(span, u, p, U) {\n  const N = [];\n  const left = [];\n  const right = [];\n  N[0] = 1;\n  for (let j = 1; j <= p; ++j) {\n    left[j] = u - U[span + 1 - j];\n    right[j] = U[span + j] - u;\n    let saved = 0;\n    for (let r = 0; r < j; ++r) {\n      const rv = right[r + 1];\n      const lv = left[j - r];\n      const temp = N[r] / (rv + lv);\n      N[r] = saved + rv * temp;\n      saved = lv * temp;\n    }\n    N[j] = saved;\n  }\n  return N;\n}\nfunction calcBSplinePoint(p, U, P, u) {\n  const span = findSpan(p, u, U);\n  const N = calcBasisFunctions(span, u, p, U);\n  const C = new Vector4(0, 0, 0, 0);\n  for (let j = 0; j <= p; ++j) {\n    const point = P[span - p + j];\n    const Nj = N[j];\n    const wNj = point.w * Nj;\n    C.x += point.x * wNj;\n    C.y += point.y * wNj;\n    C.z += point.z * wNj;\n    C.w += point.w * Nj;\n  }\n  return C;\n}\nfunction calcBasisFunctionDerivatives(span, u, p, n, U) {\n  const zeroArr = [];\n  for (let i = 0; i <= p; ++i)\n    zeroArr[i] = 0;\n  const ders = [];\n  for (let i = 0; i <= n; ++i)\n    ders[i] = zeroArr.slice(0);\n  const ndu = [];\n  for (let i = 0; i <= p; ++i)\n    ndu[i] = zeroArr.slice(0);\n  ndu[0][0] = 1;\n  const left = zeroArr.slice(0);\n  const right = zeroArr.slice(0);\n  for (let j = 1; j <= p; ++j) {\n    left[j] = u - U[span + 1 - j];\n    right[j] = U[span + j] - u;\n    let saved = 0;\n    for (let r2 = 0; r2 < j; ++r2) {\n      const rv = right[r2 + 1];\n      const lv = left[j - r2];\n      ndu[j][r2] = rv + lv;\n      const temp = ndu[r2][j - 1] / ndu[j][r2];\n      ndu[r2][j] = saved + rv * temp;\n      saved = lv * temp;\n    }\n    ndu[j][j] = saved;\n  }\n  for (let j = 0; j <= p; ++j) {\n    ders[0][j] = ndu[j][p];\n  }\n  for (let r2 = 0; r2 <= p; ++r2) {\n    let s1 = 0;\n    let s2 = 1;\n    const a = [];\n    for (let i = 0; i <= p; ++i) {\n      a[i] = zeroArr.slice(0);\n    }\n    a[0][0] = 1;\n    for (let k = 1; k <= n; ++k) {\n      let d = 0;\n      const rk = r2 - k;\n      const pk = p - k;\n      if (r2 >= k) {\n        a[s2][0] = a[s1][0] / ndu[pk + 1][rk];\n        d = a[s2][0] * ndu[rk][pk];\n      }\n      const j1 = rk >= -1 ? 1 : -rk;\n      const j2 = r2 - 1 <= pk ? k - 1 : p - r2;\n      for (let j3 = j1; j3 <= j2; ++j3) {\n        a[s2][j3] = (a[s1][j3] - a[s1][j3 - 1]) / ndu[pk + 1][rk + j3];\n        d += a[s2][j3] * ndu[rk + j3][pk];\n      }\n      if (r2 <= pk) {\n        a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r2];\n        d += a[s2][k] * ndu[r2][pk];\n      }\n      ders[k][r2] = d;\n      const j = s1;\n      s1 = s2;\n      s2 = j;\n    }\n  }\n  let r = p;\n  for (let k = 1; k <= n; ++k) {\n    for (let j = 0; j <= p; ++j) {\n      ders[k][j] *= r;\n    }\n    r *= p - k;\n  }\n  return ders;\n}\nfunction calcBSplineDerivatives(p, U, P, u, nd) {\n  const du = nd < p ? nd : p;\n  const CK = [];\n  const span = findSpan(p, u, U);\n  const nders = calcBasisFunctionDerivatives(span, u, p, du, U);\n  const Pw = [];\n  for (let i = 0; i < P.length; ++i) {\n    const point = P[i].clone();\n    const w = point.w;\n    point.x *= w;\n    point.y *= w;\n    point.z *= w;\n    Pw[i] = point;\n  }\n  for (let k = 0; k <= du; ++k) {\n    const point = Pw[span - p].clone().multiplyScalar(nders[k][0]);\n    for (let j = 1; j <= p; ++j) {\n      point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));\n    }\n    CK[k] = point;\n  }\n  for (let k = du + 1; k <= nd + 1; ++k) {\n    CK[k] = new Vector4(0, 0, 0);\n  }\n  return CK;\n}\nfunction calcKoverI(k, i) {\n  let nom = 1;\n  for (let j = 2; j <= k; ++j) {\n    nom *= j;\n  }\n  let denom = 1;\n  for (let j = 2; j <= i; ++j) {\n    denom *= j;\n  }\n  for (let j = 2; j <= k - i; ++j) {\n    denom *= j;\n  }\n  return nom / denom;\n}\nfunction calcRationalCurveDerivatives(Pders) {\n  const nd = Pders.length;\n  const Aders = [];\n  const wders = [];\n  for (let i = 0; i < nd; ++i) {\n    const point = Pders[i];\n    Aders[i] = new Vector3(point.x, point.y, point.z);\n    wders[i] = point.w;\n  }\n  const CK = [];\n  for (let k = 0; k < nd; ++k) {\n    const v = Aders[k].clone();\n    for (let i = 1; i <= k; ++i) {\n      v.sub(CK[k - i].clone().multiplyScalar(calcKoverI(k, i) * wders[i]));\n    }\n    CK[k] = v.divideScalar(wders[0]);\n  }\n  return CK;\n}\nfunction calcNURBSDerivatives(p, U, P, u, nd) {\n  const Pders = calcBSplineDerivatives(p, U, P, u, nd);\n  return calcRationalCurveDerivatives(Pders);\n}\nfunction calcSurfacePoint(p, q, U, V, P, u, v, target) {\n  const uspan = findSpan(p, u, U);\n  const vspan = findSpan(q, v, V);\n  const Nu = calcBasisFunctions(uspan, u, p, U);\n  const Nv = calcBasisFunctions(vspan, v, q, V);\n  const temp = [];\n  for (let l = 0; l <= q; ++l) {\n    temp[l] = new Vector4(0, 0, 0, 0);\n    for (let k = 0; k <= p; ++k) {\n      const point = P[uspan - p + k][vspan - q + l].clone();\n      const w = point.w;\n      point.x *= w;\n      point.y *= w;\n      point.z *= w;\n      temp[l].add(point.multiplyScalar(Nu[k]));\n    }\n  }\n  const Sw = new Vector4(0, 0, 0, 0);\n  for (let l = 0; l <= q; ++l) {\n    Sw.add(temp[l].multiplyScalar(Nv[l]));\n  }\n  Sw.divideScalar(Sw.w);\n  target.set(Sw.x, Sw.y, Sw.z);\n}\nexport {\n  calcBSplineDerivatives,\n  calcBSplinePoint,\n  calcBasisFunctionDerivatives,\n  calcBasisFunctions,\n  calcKoverI,\n  calcNURBSDerivatives,\n  calcRationalCurveDerivatives,\n  calcSurfacePoint,\n  findSpan\n};\n//# sourceMappingURL=NURBSUtils.js.map\n","import { Curve, Vector4, Vector3 } from \"three\";\nimport { calcBSplinePoint, calcNURBSDerivatives } from \"./NURBSUtils.js\";\nclass NURBSCurve extends Curve {\n  constructor(degree, knots, controlPoints, startKnot, endKnot) {\n    super();\n    this.degree = degree;\n    this.knots = knots;\n    this.controlPoints = [];\n    this.startKnot = startKnot || 0;\n    this.endKnot = endKnot || this.knots.length - 1;\n    for (let i = 0; i < controlPoints.length; ++i) {\n      const point = controlPoints[i];\n      this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w);\n    }\n  }\n  getPoint(t, optionalTarget) {\n    const point = optionalTarget || new Vector3();\n    const u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]);\n    const hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);\n    if (hpoint.w != 1) {\n      hpoint.divideScalar(hpoint.w);\n    }\n    return point.set(hpoint.x, hpoint.y, hpoint.z);\n  }\n  getTangent(t, optionalTarget) {\n    const tangent = optionalTarget || new Vector3();\n    const u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);\n    const ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);\n    tangent.copy(ders[1]).normalize();\n    return tangent;\n  }\n}\nexport {\n  NURBSCurve\n};\n//# sourceMappingURL=NURBSCurve.js.map\n","import { Loader, LoaderUtils, FileLoader, TextureLoader, RepeatWrapping, ClampToEdgeWrapping, Texture, MeshPhongMaterial, MeshLambertMaterial, Color, EquirectangularReflectionMapping, Matrix4, Group, Bone, PropertyBinding, Object3D, OrthographicCamera, PerspectiveCamera, PointLight, MathUtils, SpotLight, DirectionalLight, SkinnedMesh, Mesh, LineBasicMaterial, Line, Vector3, Skeleton, AmbientLight, BufferGeometry, Float32BufferAttribute, Uint16BufferAttribute, Matrix3, Vector4, AnimationClip, Quaternion, Euler, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack } from \"three\";\nimport { unzlibSync } from \"fflate\";\nimport { NURBSCurve } from \"../curves/NURBSCurve.js\";\nimport { decodeText } from \"../_polyfill/LoaderUtils.js\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nlet fbxTree;\nlet connections;\nlet sceneGraph;\nclass FBXLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(\n      url,\n      function(buffer) {\n        try {\n          onLoad(scope.parse(buffer, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  parse(FBXBuffer, path) {\n    if (isFbxFormatBinary(FBXBuffer)) {\n      fbxTree = new BinaryParser().parse(FBXBuffer);\n    } else {\n      const FBXText = convertArrayBufferToString(FBXBuffer);\n      if (!isFbxFormatASCII(FBXText)) {\n        throw new Error(\"THREE.FBXLoader: Unknown format.\");\n      }\n      if (getFbxVersion(FBXText) < 7e3) {\n        throw new Error(\"THREE.FBXLoader: FBX version not supported, FileVersion: \" + getFbxVersion(FBXText));\n      }\n      fbxTree = new TextParser().parse(FBXText);\n    }\n    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);\n  }\n}\nclass FBXTreeParser {\n  constructor(textureLoader, manager) {\n    this.textureLoader = textureLoader;\n    this.manager = manager;\n  }\n  parse() {\n    connections = this.parseConnections();\n    const images = this.parseImages();\n    const textures = this.parseTextures(images);\n    const materials = this.parseMaterials(textures);\n    const deformers = this.parseDeformers();\n    const geometryMap = new GeometryParser().parse(deformers);\n    this.parseScene(deformers, geometryMap, materials);\n    return sceneGraph;\n  }\n  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n  // and details the connection type\n  parseConnections() {\n    const connectionMap = /* @__PURE__ */ new Map();\n    if (\"Connections\" in fbxTree) {\n      const rawConnections = fbxTree.Connections.connections;\n      rawConnections.forEach(function(rawConnection) {\n        const fromID = rawConnection[0];\n        const toID = rawConnection[1];\n        const relationship = rawConnection[2];\n        if (!connectionMap.has(fromID)) {\n          connectionMap.set(fromID, {\n            parents: [],\n            children: []\n          });\n        }\n        const parentRelationship = { ID: toID, relationship };\n        connectionMap.get(fromID).parents.push(parentRelationship);\n        if (!connectionMap.has(toID)) {\n          connectionMap.set(toID, {\n            parents: [],\n            children: []\n          });\n        }\n        const childRelationship = { ID: fromID, relationship };\n        connectionMap.get(toID).children.push(childRelationship);\n      });\n    }\n    return connectionMap;\n  }\n  // Parse FBXTree.Objects.Video for embedded image data\n  // These images are connected to textures in FBXTree.Objects.Textures\n  // via FBXTree.Connections.\n  parseImages() {\n    const images = {};\n    const blobs = {};\n    if (\"Video\" in fbxTree.Objects) {\n      const videoNodes = fbxTree.Objects.Video;\n      for (const nodeID in videoNodes) {\n        const videoNode = videoNodes[nodeID];\n        const id = parseInt(nodeID);\n        images[id] = videoNode.RelativeFilename || videoNode.Filename;\n        if (\"Content\" in videoNode) {\n          const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;\n          const base64Content = typeof videoNode.Content === \"string\" && videoNode.Content !== \"\";\n          if (arrayBufferContent || base64Content) {\n            const image = this.parseImage(videoNodes[nodeID]);\n            blobs[videoNode.RelativeFilename || videoNode.Filename] = image;\n          }\n        }\n      }\n    }\n    for (const id in images) {\n      const filename = images[id];\n      if (blobs[filename] !== void 0)\n        images[id] = blobs[filename];\n      else\n        images[id] = images[id].split(\"\\\\\").pop();\n    }\n    return images;\n  }\n  // Parse embedded image data in FBXTree.Video.Content\n  parseImage(videoNode) {\n    const content = videoNode.Content;\n    const fileName = videoNode.RelativeFilename || videoNode.Filename;\n    const extension = fileName.slice(fileName.lastIndexOf(\".\") + 1).toLowerCase();\n    let type;\n    switch (extension) {\n      case \"bmp\":\n        type = \"image/bmp\";\n        break;\n      case \"jpg\":\n      case \"jpeg\":\n        type = \"image/jpeg\";\n        break;\n      case \"png\":\n        type = \"image/png\";\n        break;\n      case \"tif\":\n        type = \"image/tiff\";\n        break;\n      case \"tga\":\n        if (this.manager.getHandler(\".tga\") === null) {\n          console.warn(\"FBXLoader: TGA loader not found, skipping \", fileName);\n        }\n        type = \"image/tga\";\n        break;\n      default:\n        console.warn('FBXLoader: Image type \"' + extension + '\" is not supported.');\n        return;\n    }\n    if (typeof content === \"string\") {\n      return \"data:\" + type + \";base64,\" + content;\n    } else {\n      const array = new Uint8Array(content);\n      return window.URL.createObjectURL(new Blob([array], { type }));\n    }\n  }\n  // Parse nodes in FBXTree.Objects.Texture\n  // These contain details such as UV scaling, cropping, rotation etc and are connected\n  // to images in FBXTree.Objects.Video\n  parseTextures(images) {\n    const textureMap = /* @__PURE__ */ new Map();\n    if (\"Texture\" in fbxTree.Objects) {\n      const textureNodes = fbxTree.Objects.Texture;\n      for (const nodeID in textureNodes) {\n        const texture = this.parseTexture(textureNodes[nodeID], images);\n        textureMap.set(parseInt(nodeID), texture);\n      }\n    }\n    return textureMap;\n  }\n  // Parse individual node in FBXTree.Objects.Texture\n  parseTexture(textureNode, images) {\n    const texture = this.loadTexture(textureNode, images);\n    texture.ID = textureNode.id;\n    texture.name = textureNode.attrName;\n    const wrapModeU = textureNode.WrapModeU;\n    const wrapModeV = textureNode.WrapModeV;\n    const valueU = wrapModeU !== void 0 ? wrapModeU.value : 0;\n    const valueV = wrapModeV !== void 0 ? wrapModeV.value : 0;\n    texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;\n    texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;\n    if (\"Scaling\" in textureNode) {\n      const values = textureNode.Scaling.value;\n      texture.repeat.x = values[0];\n      texture.repeat.y = values[1];\n    }\n    return texture;\n  }\n  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader\n  loadTexture(textureNode, images) {\n    let fileName;\n    const currentPath = this.textureLoader.path;\n    const children = connections.get(textureNode.id).children;\n    if (children !== void 0 && children.length > 0 && images[children[0].ID] !== void 0) {\n      fileName = images[children[0].ID];\n      if (fileName.indexOf(\"blob:\") === 0 || fileName.indexOf(\"data:\") === 0) {\n        this.textureLoader.setPath(void 0);\n      }\n    }\n    let texture;\n    const extension = textureNode.FileName.slice(-3).toLowerCase();\n    if (extension === \"tga\") {\n      const loader = this.manager.getHandler(\".tga\");\n      if (loader === null) {\n        console.warn(\"FBXLoader: TGA loader not found, creating placeholder texture for\", textureNode.RelativeFilename);\n        texture = new Texture();\n      } else {\n        loader.setPath(this.textureLoader.path);\n        texture = loader.load(fileName);\n      }\n    } else if (extension === \"psd\") {\n      console.warn(\n        \"FBXLoader: PSD textures are not supported, creating placeholder texture for\",\n        textureNode.RelativeFilename\n      );\n      texture = new Texture();\n    } else {\n      texture = this.textureLoader.load(fileName);\n    }\n    this.textureLoader.setPath(currentPath);\n    return texture;\n  }\n  // Parse nodes in FBXTree.Objects.Material\n  parseMaterials(textureMap) {\n    const materialMap = /* @__PURE__ */ new Map();\n    if (\"Material\" in fbxTree.Objects) {\n      const materialNodes = fbxTree.Objects.Material;\n      for (const nodeID in materialNodes) {\n        const material = this.parseMaterial(materialNodes[nodeID], textureMap);\n        if (material !== null)\n          materialMap.set(parseInt(nodeID), material);\n      }\n    }\n    return materialMap;\n  }\n  // Parse single node in FBXTree.Objects.Material\n  // Materials are connected to texture maps in FBXTree.Objects.Textures\n  // FBX format currently only supports Lambert and Phong shading models\n  parseMaterial(materialNode, textureMap) {\n    const ID = materialNode.id;\n    const name = materialNode.attrName;\n    let type = materialNode.ShadingModel;\n    if (typeof type === \"object\") {\n      type = type.value;\n    }\n    if (!connections.has(ID))\n      return null;\n    const parameters = this.parseParameters(materialNode, textureMap, ID);\n    let material;\n    switch (type.toLowerCase()) {\n      case \"phong\":\n        material = new MeshPhongMaterial();\n        break;\n      case \"lambert\":\n        material = new MeshLambertMaterial();\n        break;\n      default:\n        console.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type);\n        material = new MeshPhongMaterial();\n        break;\n    }\n    material.setValues(parameters);\n    material.name = name;\n    return material;\n  }\n  // Parse FBX material and return parameters suitable for a three.js material\n  // Also parse the texture map and return any textures associated with the material\n  parseParameters(materialNode, textureMap, ID) {\n    const parameters = {};\n    if (materialNode.BumpFactor) {\n      parameters.bumpScale = materialNode.BumpFactor.value;\n    }\n    if (materialNode.Diffuse) {\n      parameters.color = new Color().fromArray(materialNode.Diffuse.value);\n    } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === \"Color\" || materialNode.DiffuseColor.type === \"ColorRGB\")) {\n      parameters.color = new Color().fromArray(materialNode.DiffuseColor.value);\n    }\n    if (materialNode.DisplacementFactor) {\n      parameters.displacementScale = materialNode.DisplacementFactor.value;\n    }\n    if (materialNode.Emissive) {\n      parameters.emissive = new Color().fromArray(materialNode.Emissive.value);\n    } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === \"Color\" || materialNode.EmissiveColor.type === \"ColorRGB\")) {\n      parameters.emissive = new Color().fromArray(materialNode.EmissiveColor.value);\n    }\n    if (materialNode.EmissiveFactor) {\n      parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);\n    }\n    if (materialNode.Opacity) {\n      parameters.opacity = parseFloat(materialNode.Opacity.value);\n    }\n    if (parameters.opacity < 1) {\n      parameters.transparent = true;\n    }\n    if (materialNode.ReflectionFactor) {\n      parameters.reflectivity = materialNode.ReflectionFactor.value;\n    }\n    if (materialNode.Shininess) {\n      parameters.shininess = materialNode.Shininess.value;\n    }\n    if (materialNode.Specular) {\n      parameters.specular = new Color().fromArray(materialNode.Specular.value);\n    } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === \"Color\") {\n      parameters.specular = new Color().fromArray(materialNode.SpecularColor.value);\n    }\n    const scope = this;\n    connections.get(ID).children.forEach(function(child) {\n      const type = child.relationship;\n      switch (type) {\n        case \"Bump\":\n          parameters.bumpMap = scope.getTexture(textureMap, child.ID);\n          break;\n        case \"Maya|TEX_ao_map\":\n          parameters.aoMap = scope.getTexture(textureMap, child.ID);\n          break;\n        case \"DiffuseColor\":\n        case \"Maya|TEX_color_map\":\n          parameters.map = scope.getTexture(textureMap, child.ID);\n          if (parameters.map !== void 0) {\n            if (\"colorSpace\" in parameters.map)\n              parameters.map.colorSpace = \"srgb\";\n            else\n              parameters.map.encoding = 3001;\n          }\n          break;\n        case \"DisplacementColor\":\n          parameters.displacementMap = scope.getTexture(textureMap, child.ID);\n          break;\n        case \"EmissiveColor\":\n          parameters.emissiveMap = scope.getTexture(textureMap, child.ID);\n          if (parameters.emissiveMap !== void 0) {\n            if (\"colorSpace\" in parameters.emissiveMap)\n              parameters.emissiveMap.colorSpace = \"srgb\";\n            else\n              parameters.emissiveMap.encoding = 3001;\n          }\n          break;\n        case \"NormalMap\":\n        case \"Maya|TEX_normal_map\":\n          parameters.normalMap = scope.getTexture(textureMap, child.ID);\n          break;\n        case \"ReflectionColor\":\n          parameters.envMap = scope.getTexture(textureMap, child.ID);\n          if (parameters.envMap !== void 0) {\n            parameters.envMap.mapping = EquirectangularReflectionMapping;\n            if (\"colorSpace\" in parameters.envMap)\n              parameters.envMap.colorSpace = \"srgb\";\n            else\n              parameters.envMap.encoding = 3001;\n          }\n          break;\n        case \"SpecularColor\":\n          parameters.specularMap = scope.getTexture(textureMap, child.ID);\n          if (parameters.specularMap !== void 0) {\n            if (\"colorSpace\" in parameters.specularMap)\n              parameters.specularMap.colorSpace = \"srgb\";\n            else\n              parameters.specularMap.encoding = 3001;\n          }\n          break;\n        case \"TransparentColor\":\n        case \"TransparencyFactor\":\n          parameters.alphaMap = scope.getTexture(textureMap, child.ID);\n          parameters.transparent = true;\n          break;\n        case \"AmbientColor\":\n        case \"ShininessExponent\":\n        case \"SpecularFactor\":\n        case \"VectorDisplacementColor\":\n        default:\n          console.warn(\"THREE.FBXLoader: %s map is not supported in three.js, skipping texture.\", type);\n          break;\n      }\n    });\n    return parameters;\n  }\n  // get a texture from the textureMap for use by a material.\n  getTexture(textureMap, id) {\n    if (\"LayeredTexture\" in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {\n      console.warn(\"THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.\");\n      id = connections.get(id).children[0].ID;\n    }\n    return textureMap.get(id);\n  }\n  // Parse nodes in FBXTree.Objects.Deformer\n  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n  parseDeformers() {\n    const skeletons = {};\n    const morphTargets = {};\n    if (\"Deformer\" in fbxTree.Objects) {\n      const DeformerNodes = fbxTree.Objects.Deformer;\n      for (const nodeID in DeformerNodes) {\n        const deformerNode = DeformerNodes[nodeID];\n        const relationships = connections.get(parseInt(nodeID));\n        if (deformerNode.attrType === \"Skin\") {\n          const skeleton = this.parseSkeleton(relationships, DeformerNodes);\n          skeleton.ID = nodeID;\n          if (relationships.parents.length > 1) {\n            console.warn(\"THREE.FBXLoader: skeleton attached to more than one geometry is not supported.\");\n          }\n          skeleton.geometryID = relationships.parents[0].ID;\n          skeletons[nodeID] = skeleton;\n        } else if (deformerNode.attrType === \"BlendShape\") {\n          const morphTarget = {\n            id: nodeID\n          };\n          morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);\n          morphTarget.id = nodeID;\n          if (relationships.parents.length > 1) {\n            console.warn(\"THREE.FBXLoader: morph target attached to more than one geometry is not supported.\");\n          }\n          morphTargets[nodeID] = morphTarget;\n        }\n      }\n    }\n    return {\n      skeletons,\n      morphTargets\n    };\n  }\n  // Parse single nodes in FBXTree.Objects.Deformer\n  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n  // Each skin node represents a skeleton and each cluster node represents a bone\n  parseSkeleton(relationships, deformerNodes) {\n    const rawBones = [];\n    relationships.children.forEach(function(child) {\n      const boneNode = deformerNodes[child.ID];\n      if (boneNode.attrType !== \"Cluster\")\n        return;\n      const rawBone = {\n        ID: child.ID,\n        indices: [],\n        weights: [],\n        transformLink: new Matrix4().fromArray(boneNode.TransformLink.a)\n        // transform: new Matrix4().fromArray( boneNode.Transform.a ),\n        // linkMode: boneNode.Mode,\n      };\n      if (\"Indexes\" in boneNode) {\n        rawBone.indices = boneNode.Indexes.a;\n        rawBone.weights = boneNode.Weights.a;\n      }\n      rawBones.push(rawBone);\n    });\n    return {\n      rawBones,\n      bones: []\n    };\n  }\n  // The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n  parseMorphTargets(relationships, deformerNodes) {\n    const rawMorphTargets = [];\n    for (let i = 0; i < relationships.children.length; i++) {\n      const child = relationships.children[i];\n      const morphTargetNode = deformerNodes[child.ID];\n      const rawMorphTarget = {\n        name: morphTargetNode.attrName,\n        initialWeight: morphTargetNode.DeformPercent,\n        id: morphTargetNode.id,\n        fullWeights: morphTargetNode.FullWeights.a\n      };\n      if (morphTargetNode.attrType !== \"BlendShapeChannel\")\n        return;\n      rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function(child2) {\n        return child2.relationship === void 0;\n      })[0].ID;\n      rawMorphTargets.push(rawMorphTarget);\n    }\n    return rawMorphTargets;\n  }\n  // create the main Group() to be returned by the loader\n  parseScene(deformers, geometryMap, materialMap) {\n    sceneGraph = new Group();\n    const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);\n    const modelNodes = fbxTree.Objects.Model;\n    const scope = this;\n    modelMap.forEach(function(model) {\n      const modelNode = modelNodes[model.ID];\n      scope.setLookAtProperties(model, modelNode);\n      const parentConnections = connections.get(model.ID).parents;\n      parentConnections.forEach(function(connection) {\n        const parent = modelMap.get(connection.ID);\n        if (parent !== void 0)\n          parent.add(model);\n      });\n      if (model.parent === null) {\n        sceneGraph.add(model);\n      }\n    });\n    this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);\n    this.createAmbientLight();\n    sceneGraph.traverse(function(node) {\n      if (node.userData.transformData) {\n        if (node.parent) {\n          node.userData.transformData.parentMatrix = node.parent.matrix;\n          node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;\n        }\n        const transform = generateTransform(node.userData.transformData);\n        node.applyMatrix4(transform);\n        node.updateWorldMatrix();\n      }\n    });\n    const animations = new AnimationParser().parse();\n    if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {\n      sceneGraph.children[0].animations = animations;\n      sceneGraph = sceneGraph.children[0];\n    }\n    sceneGraph.animations = animations;\n  }\n  // parse nodes in FBXTree.Objects.Model\n  parseModels(skeletons, geometryMap, materialMap) {\n    const modelMap = /* @__PURE__ */ new Map();\n    const modelNodes = fbxTree.Objects.Model;\n    for (const nodeID in modelNodes) {\n      const id = parseInt(nodeID);\n      const node = modelNodes[nodeID];\n      const relationships = connections.get(id);\n      let model = this.buildSkeleton(relationships, skeletons, id, node.attrName);\n      if (!model) {\n        switch (node.attrType) {\n          case \"Camera\":\n            model = this.createCamera(relationships);\n            break;\n          case \"Light\":\n            model = this.createLight(relationships);\n            break;\n          case \"Mesh\":\n            model = this.createMesh(relationships, geometryMap, materialMap);\n            break;\n          case \"NurbsCurve\":\n            model = this.createCurve(relationships, geometryMap);\n            break;\n          case \"LimbNode\":\n          case \"Root\":\n            model = new Bone();\n            break;\n          case \"Null\":\n          default:\n            model = new Group();\n            break;\n        }\n        model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : \"\";\n        model.ID = id;\n      }\n      this.getTransformData(model, node);\n      modelMap.set(id, model);\n    }\n    return modelMap;\n  }\n  buildSkeleton(relationships, skeletons, id, name) {\n    let bone = null;\n    relationships.parents.forEach(function(parent) {\n      for (const ID in skeletons) {\n        const skeleton = skeletons[ID];\n        skeleton.rawBones.forEach(function(rawBone, i) {\n          if (rawBone.ID === parent.ID) {\n            const subBone = bone;\n            bone = new Bone();\n            bone.matrixWorld.copy(rawBone.transformLink);\n            bone.name = name ? PropertyBinding.sanitizeNodeName(name) : \"\";\n            bone.ID = id;\n            skeleton.bones[i] = bone;\n            if (subBone !== null) {\n              bone.add(subBone);\n            }\n          }\n        });\n      }\n    });\n    return bone;\n  }\n  // create a PerspectiveCamera or OrthographicCamera\n  createCamera(relationships) {\n    let model;\n    let cameraAttribute;\n    relationships.children.forEach(function(child) {\n      const attr = fbxTree.Objects.NodeAttribute[child.ID];\n      if (attr !== void 0) {\n        cameraAttribute = attr;\n      }\n    });\n    if (cameraAttribute === void 0) {\n      model = new Object3D();\n    } else {\n      let type = 0;\n      if (cameraAttribute.CameraProjectionType !== void 0 && cameraAttribute.CameraProjectionType.value === 1) {\n        type = 1;\n      }\n      let nearClippingPlane = 1;\n      if (cameraAttribute.NearPlane !== void 0) {\n        nearClippingPlane = cameraAttribute.NearPlane.value / 1e3;\n      }\n      let farClippingPlane = 1e3;\n      if (cameraAttribute.FarPlane !== void 0) {\n        farClippingPlane = cameraAttribute.FarPlane.value / 1e3;\n      }\n      let width = window.innerWidth;\n      let height = window.innerHeight;\n      if (cameraAttribute.AspectWidth !== void 0 && cameraAttribute.AspectHeight !== void 0) {\n        width = cameraAttribute.AspectWidth.value;\n        height = cameraAttribute.AspectHeight.value;\n      }\n      const aspect = width / height;\n      let fov = 45;\n      if (cameraAttribute.FieldOfView !== void 0) {\n        fov = cameraAttribute.FieldOfView.value;\n      }\n      const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n      switch (type) {\n        case 0:\n          model = new PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);\n          if (focalLength !== null)\n            model.setFocalLength(focalLength);\n          break;\n        case 1:\n          model = new OrthographicCamera(\n            -width / 2,\n            width / 2,\n            height / 2,\n            -height / 2,\n            nearClippingPlane,\n            farClippingPlane\n          );\n          break;\n        default:\n          console.warn(\"THREE.FBXLoader: Unknown camera type \" + type + \".\");\n          model = new Object3D();\n          break;\n      }\n    }\n    return model;\n  }\n  // Create a DirectionalLight, PointLight or SpotLight\n  createLight(relationships) {\n    let model;\n    let lightAttribute;\n    relationships.children.forEach(function(child) {\n      const attr = fbxTree.Objects.NodeAttribute[child.ID];\n      if (attr !== void 0) {\n        lightAttribute = attr;\n      }\n    });\n    if (lightAttribute === void 0) {\n      model = new Object3D();\n    } else {\n      let type;\n      if (lightAttribute.LightType === void 0) {\n        type = 0;\n      } else {\n        type = lightAttribute.LightType.value;\n      }\n      let color = 16777215;\n      if (lightAttribute.Color !== void 0) {\n        color = new Color().fromArray(lightAttribute.Color.value);\n      }\n      let intensity = lightAttribute.Intensity === void 0 ? 1 : lightAttribute.Intensity.value / 100;\n      if (lightAttribute.CastLightOnObject !== void 0 && lightAttribute.CastLightOnObject.value === 0) {\n        intensity = 0;\n      }\n      let distance = 0;\n      if (lightAttribute.FarAttenuationEnd !== void 0) {\n        if (lightAttribute.EnableFarAttenuation !== void 0 && lightAttribute.EnableFarAttenuation.value === 0) {\n          distance = 0;\n        } else {\n          distance = lightAttribute.FarAttenuationEnd.value;\n        }\n      }\n      const decay = 1;\n      switch (type) {\n        case 0:\n          model = new PointLight(color, intensity, distance, decay);\n          break;\n        case 1:\n          model = new DirectionalLight(color, intensity);\n          break;\n        case 2:\n          let angle = Math.PI / 3;\n          if (lightAttribute.InnerAngle !== void 0) {\n            angle = MathUtils.degToRad(lightAttribute.InnerAngle.value);\n          }\n          let penumbra = 0;\n          if (lightAttribute.OuterAngle !== void 0) {\n            penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value);\n            penumbra = Math.max(penumbra, 1);\n          }\n          model = new SpotLight(color, intensity, distance, angle, penumbra, decay);\n          break;\n        default:\n          console.warn(\n            \"THREE.FBXLoader: Unknown light type \" + lightAttribute.LightType.value + \", defaulting to a PointLight.\"\n          );\n          model = new PointLight(color, intensity);\n          break;\n      }\n      if (lightAttribute.CastShadows !== void 0 && lightAttribute.CastShadows.value === 1) {\n        model.castShadow = true;\n      }\n    }\n    return model;\n  }\n  createMesh(relationships, geometryMap, materialMap) {\n    let model;\n    let geometry = null;\n    let material = null;\n    const materials = [];\n    relationships.children.forEach(function(child) {\n      if (geometryMap.has(child.ID)) {\n        geometry = geometryMap.get(child.ID);\n      }\n      if (materialMap.has(child.ID)) {\n        materials.push(materialMap.get(child.ID));\n      }\n    });\n    if (materials.length > 1) {\n      material = materials;\n    } else if (materials.length > 0) {\n      material = materials[0];\n    } else {\n      material = new MeshPhongMaterial({ color: 13421772 });\n      materials.push(material);\n    }\n    if (\"color\" in geometry.attributes) {\n      materials.forEach(function(material2) {\n        material2.vertexColors = true;\n      });\n    }\n    if (geometry.FBX_Deformer) {\n      model = new SkinnedMesh(geometry, material);\n      model.normalizeSkinWeights();\n    } else {\n      model = new Mesh(geometry, material);\n    }\n    return model;\n  }\n  createCurve(relationships, geometryMap) {\n    const geometry = relationships.children.reduce(function(geo, child) {\n      if (geometryMap.has(child.ID))\n        geo = geometryMap.get(child.ID);\n      return geo;\n    }, null);\n    const material = new LineBasicMaterial({ color: 3342591, linewidth: 1 });\n    return new Line(geometry, material);\n  }\n  // parse the model node for transform data\n  getTransformData(model, modelNode) {\n    const transformData = {};\n    if (\"InheritType\" in modelNode)\n      transformData.inheritType = parseInt(modelNode.InheritType.value);\n    if (\"RotationOrder\" in modelNode)\n      transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);\n    else\n      transformData.eulerOrder = \"ZYX\";\n    if (\"Lcl_Translation\" in modelNode)\n      transformData.translation = modelNode.Lcl_Translation.value;\n    if (\"PreRotation\" in modelNode)\n      transformData.preRotation = modelNode.PreRotation.value;\n    if (\"Lcl_Rotation\" in modelNode)\n      transformData.rotation = modelNode.Lcl_Rotation.value;\n    if (\"PostRotation\" in modelNode)\n      transformData.postRotation = modelNode.PostRotation.value;\n    if (\"Lcl_Scaling\" in modelNode)\n      transformData.scale = modelNode.Lcl_Scaling.value;\n    if (\"ScalingOffset\" in modelNode)\n      transformData.scalingOffset = modelNode.ScalingOffset.value;\n    if (\"ScalingPivot\" in modelNode)\n      transformData.scalingPivot = modelNode.ScalingPivot.value;\n    if (\"RotationOffset\" in modelNode)\n      transformData.rotationOffset = modelNode.RotationOffset.value;\n    if (\"RotationPivot\" in modelNode)\n      transformData.rotationPivot = modelNode.RotationPivot.value;\n    model.userData.transformData = transformData;\n  }\n  setLookAtProperties(model, modelNode) {\n    if (\"LookAtProperty\" in modelNode) {\n      const children = connections.get(model.ID).children;\n      children.forEach(function(child) {\n        if (child.relationship === \"LookAtProperty\") {\n          const lookAtTarget = fbxTree.Objects.Model[child.ID];\n          if (\"Lcl_Translation\" in lookAtTarget) {\n            const pos = lookAtTarget.Lcl_Translation.value;\n            if (model.target !== void 0) {\n              model.target.position.fromArray(pos);\n              sceneGraph.add(model.target);\n            } else {\n              model.lookAt(new Vector3().fromArray(pos));\n            }\n          }\n        }\n      });\n    }\n  }\n  bindSkeleton(skeletons, geometryMap, modelMap) {\n    const bindMatrices = this.parsePoseNodes();\n    for (const ID in skeletons) {\n      const skeleton = skeletons[ID];\n      const parents = connections.get(parseInt(skeleton.ID)).parents;\n      parents.forEach(function(parent) {\n        if (geometryMap.has(parent.ID)) {\n          const geoID = parent.ID;\n          const geoRelationships = connections.get(geoID);\n          geoRelationships.parents.forEach(function(geoConnParent) {\n            if (modelMap.has(geoConnParent.ID)) {\n              const model = modelMap.get(geoConnParent.ID);\n              model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);\n            }\n          });\n        }\n      });\n    }\n  }\n  parsePoseNodes() {\n    const bindMatrices = {};\n    if (\"Pose\" in fbxTree.Objects) {\n      const BindPoseNode = fbxTree.Objects.Pose;\n      for (const nodeID in BindPoseNode) {\n        if (BindPoseNode[nodeID].attrType === \"BindPose\" && BindPoseNode[nodeID].NbPoseNodes > 0) {\n          const poseNodes = BindPoseNode[nodeID].PoseNode;\n          if (Array.isArray(poseNodes)) {\n            poseNodes.forEach(function(poseNode) {\n              bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a);\n            });\n          } else {\n            bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a);\n          }\n        }\n      }\n    }\n    return bindMatrices;\n  }\n  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n  createAmbientLight() {\n    if (\"GlobalSettings\" in fbxTree && \"AmbientColor\" in fbxTree.GlobalSettings) {\n      const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;\n      const r = ambientColor[0];\n      const g = ambientColor[1];\n      const b = ambientColor[2];\n      if (r !== 0 || g !== 0 || b !== 0) {\n        const color = new Color(r, g, b);\n        sceneGraph.add(new AmbientLight(color, 1));\n      }\n    }\n  }\n}\nclass GeometryParser {\n  // Parse nodes in FBXTree.Objects.Geometry\n  parse(deformers) {\n    const geometryMap = /* @__PURE__ */ new Map();\n    if (\"Geometry\" in fbxTree.Objects) {\n      const geoNodes = fbxTree.Objects.Geometry;\n      for (const nodeID in geoNodes) {\n        const relationships = connections.get(parseInt(nodeID));\n        const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);\n        geometryMap.set(parseInt(nodeID), geo);\n      }\n    }\n    return geometryMap;\n  }\n  // Parse single node in FBXTree.Objects.Geometry\n  parseGeometry(relationships, geoNode, deformers) {\n    switch (geoNode.attrType) {\n      case \"Mesh\":\n        return this.parseMeshGeometry(relationships, geoNode, deformers);\n      case \"NurbsCurve\":\n        return this.parseNurbsGeometry(geoNode);\n    }\n  }\n  // Parse single node mesh geometry in FBXTree.Objects.Geometry\n  parseMeshGeometry(relationships, geoNode, deformers) {\n    const skeletons = deformers.skeletons;\n    const morphTargets = [];\n    const modelNodes = relationships.parents.map(function(parent) {\n      return fbxTree.Objects.Model[parent.ID];\n    });\n    if (modelNodes.length === 0)\n      return;\n    const skeleton = relationships.children.reduce(function(skeleton2, child) {\n      if (skeletons[child.ID] !== void 0)\n        skeleton2 = skeletons[child.ID];\n      return skeleton2;\n    }, null);\n    relationships.children.forEach(function(child) {\n      if (deformers.morphTargets[child.ID] !== void 0) {\n        morphTargets.push(deformers.morphTargets[child.ID]);\n      }\n    });\n    const modelNode = modelNodes[0];\n    const transformData = {};\n    if (\"RotationOrder\" in modelNode)\n      transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);\n    if (\"InheritType\" in modelNode)\n      transformData.inheritType = parseInt(modelNode.InheritType.value);\n    if (\"GeometricTranslation\" in modelNode)\n      transformData.translation = modelNode.GeometricTranslation.value;\n    if (\"GeometricRotation\" in modelNode)\n      transformData.rotation = modelNode.GeometricRotation.value;\n    if (\"GeometricScaling\" in modelNode)\n      transformData.scale = modelNode.GeometricScaling.value;\n    const transform = generateTransform(transformData);\n    return this.genGeometry(geoNode, skeleton, morphTargets, transform);\n  }\n  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\n  genGeometry(geoNode, skeleton, morphTargets, preTransform) {\n    const geo = new BufferGeometry();\n    if (geoNode.attrName)\n      geo.name = geoNode.attrName;\n    const geoInfo = this.parseGeoNode(geoNode, skeleton);\n    const buffers = this.genBuffers(geoInfo);\n    const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3);\n    positionAttribute.applyMatrix4(preTransform);\n    geo.setAttribute(\"position\", positionAttribute);\n    if (buffers.colors.length > 0) {\n      geo.setAttribute(\"color\", new Float32BufferAttribute(buffers.colors, 3));\n    }\n    if (skeleton) {\n      geo.setAttribute(\"skinIndex\", new Uint16BufferAttribute(buffers.weightsIndices, 4));\n      geo.setAttribute(\"skinWeight\", new Float32BufferAttribute(buffers.vertexWeights, 4));\n      geo.FBX_Deformer = skeleton;\n    }\n    if (buffers.normal.length > 0) {\n      const normalMatrix = new Matrix3().getNormalMatrix(preTransform);\n      const normalAttribute = new Float32BufferAttribute(buffers.normal, 3);\n      normalAttribute.applyNormalMatrix(normalMatrix);\n      geo.setAttribute(\"normal\", normalAttribute);\n    }\n    buffers.uvs.forEach(function(uvBuffer, i) {\n      if (UV1 === \"uv2\")\n        i++;\n      const name = i === 0 ? \"uv\" : `uv${i}`;\n      geo.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i], 2));\n    });\n    if (geoInfo.material && geoInfo.material.mappingType !== \"AllSame\") {\n      let prevMaterialIndex = buffers.materialIndex[0];\n      let startIndex = 0;\n      buffers.materialIndex.forEach(function(currentIndex, i) {\n        if (currentIndex !== prevMaterialIndex) {\n          geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);\n          prevMaterialIndex = currentIndex;\n          startIndex = i;\n        }\n      });\n      if (geo.groups.length > 0) {\n        const lastGroup = geo.groups[geo.groups.length - 1];\n        const lastIndex = lastGroup.start + lastGroup.count;\n        if (lastIndex !== buffers.materialIndex.length) {\n          geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);\n        }\n      }\n      if (geo.groups.length === 0) {\n        geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);\n      }\n    }\n    this.addMorphTargets(geo, geoNode, morphTargets, preTransform);\n    return geo;\n  }\n  parseGeoNode(geoNode, skeleton) {\n    const geoInfo = {};\n    geoInfo.vertexPositions = geoNode.Vertices !== void 0 ? geoNode.Vertices.a : [];\n    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== void 0 ? geoNode.PolygonVertexIndex.a : [];\n    if (geoNode.LayerElementColor) {\n      geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);\n    }\n    if (geoNode.LayerElementMaterial) {\n      geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);\n    }\n    if (geoNode.LayerElementNormal) {\n      geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);\n    }\n    if (geoNode.LayerElementUV) {\n      geoInfo.uv = [];\n      let i = 0;\n      while (geoNode.LayerElementUV[i]) {\n        if (geoNode.LayerElementUV[i].UV) {\n          geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));\n        }\n        i++;\n      }\n    }\n    geoInfo.weightTable = {};\n    if (skeleton !== null) {\n      geoInfo.skeleton = skeleton;\n      skeleton.rawBones.forEach(function(rawBone, i) {\n        rawBone.indices.forEach(function(index, j) {\n          if (geoInfo.weightTable[index] === void 0)\n            geoInfo.weightTable[index] = [];\n          geoInfo.weightTable[index].push({\n            id: i,\n            weight: rawBone.weights[j]\n          });\n        });\n      });\n    }\n    return geoInfo;\n  }\n  genBuffers(geoInfo) {\n    const buffers = {\n      vertex: [],\n      normal: [],\n      colors: [],\n      uvs: [],\n      materialIndex: [],\n      vertexWeights: [],\n      weightsIndices: []\n    };\n    let polygonIndex = 0;\n    let faceLength = 0;\n    let displayedWeightsWarning = false;\n    let facePositionIndexes = [];\n    let faceNormals = [];\n    let faceColors = [];\n    let faceUVs = [];\n    let faceWeights = [];\n    let faceWeightIndices = [];\n    const scope = this;\n    geoInfo.vertexIndices.forEach(function(vertexIndex, polygonVertexIndex) {\n      let materialIndex;\n      let endOfFace = false;\n      if (vertexIndex < 0) {\n        vertexIndex = vertexIndex ^ -1;\n        endOfFace = true;\n      }\n      let weightIndices = [];\n      let weights = [];\n      facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);\n      if (geoInfo.color) {\n        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);\n        faceColors.push(data[0], data[1], data[2]);\n      }\n      if (geoInfo.skeleton) {\n        if (geoInfo.weightTable[vertexIndex] !== void 0) {\n          geoInfo.weightTable[vertexIndex].forEach(function(wt) {\n            weights.push(wt.weight);\n            weightIndices.push(wt.id);\n          });\n        }\n        if (weights.length > 4) {\n          if (!displayedWeightsWarning) {\n            console.warn(\n              \"THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.\"\n            );\n            displayedWeightsWarning = true;\n          }\n          const wIndex = [0, 0, 0, 0];\n          const Weight = [0, 0, 0, 0];\n          weights.forEach(function(weight, weightIndex) {\n            let currentWeight = weight;\n            let currentIndex = weightIndices[weightIndex];\n            Weight.forEach(function(comparedWeight, comparedWeightIndex, comparedWeightArray) {\n              if (currentWeight > comparedWeight) {\n                comparedWeightArray[comparedWeightIndex] = currentWeight;\n                currentWeight = comparedWeight;\n                const tmp = wIndex[comparedWeightIndex];\n                wIndex[comparedWeightIndex] = currentIndex;\n                currentIndex = tmp;\n              }\n            });\n          });\n          weightIndices = wIndex;\n          weights = Weight;\n        }\n        while (weights.length < 4) {\n          weights.push(0);\n          weightIndices.push(0);\n        }\n        for (let i = 0; i < 4; ++i) {\n          faceWeights.push(weights[i]);\n          faceWeightIndices.push(weightIndices[i]);\n        }\n      }\n      if (geoInfo.normal) {\n        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);\n        faceNormals.push(data[0], data[1], data[2]);\n      }\n      if (geoInfo.material && geoInfo.material.mappingType !== \"AllSame\") {\n        materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];\n      }\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function(uv, i) {\n          const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);\n          if (faceUVs[i] === void 0) {\n            faceUVs[i] = [];\n          }\n          faceUVs[i].push(data[0]);\n          faceUVs[i].push(data[1]);\n        });\n      }\n      faceLength++;\n      if (endOfFace) {\n        scope.genFace(\n          buffers,\n          geoInfo,\n          facePositionIndexes,\n          materialIndex,\n          faceNormals,\n          faceColors,\n          faceUVs,\n          faceWeights,\n          faceWeightIndices,\n          faceLength\n        );\n        polygonIndex++;\n        faceLength = 0;\n        facePositionIndexes = [];\n        faceNormals = [];\n        faceColors = [];\n        faceUVs = [];\n        faceWeights = [];\n        faceWeightIndices = [];\n      }\n    });\n    return buffers;\n  }\n  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n  genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {\n    for (let i = 2; i < faceLength; i++) {\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);\n      if (geoInfo.skeleton) {\n        buffers.vertexWeights.push(faceWeights[0]);\n        buffers.vertexWeights.push(faceWeights[1]);\n        buffers.vertexWeights.push(faceWeights[2]);\n        buffers.vertexWeights.push(faceWeights[3]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);\n        buffers.vertexWeights.push(faceWeights[i * 4]);\n        buffers.vertexWeights.push(faceWeights[i * 4 + 1]);\n        buffers.vertexWeights.push(faceWeights[i * 4 + 2]);\n        buffers.vertexWeights.push(faceWeights[i * 4 + 3]);\n        buffers.weightsIndices.push(faceWeightIndices[0]);\n        buffers.weightsIndices.push(faceWeightIndices[1]);\n        buffers.weightsIndices.push(faceWeightIndices[2]);\n        buffers.weightsIndices.push(faceWeightIndices[3]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);\n      }\n      if (geoInfo.color) {\n        buffers.colors.push(faceColors[0]);\n        buffers.colors.push(faceColors[1]);\n        buffers.colors.push(faceColors[2]);\n        buffers.colors.push(faceColors[(i - 1) * 3]);\n        buffers.colors.push(faceColors[(i - 1) * 3 + 1]);\n        buffers.colors.push(faceColors[(i - 1) * 3 + 2]);\n        buffers.colors.push(faceColors[i * 3]);\n        buffers.colors.push(faceColors[i * 3 + 1]);\n        buffers.colors.push(faceColors[i * 3 + 2]);\n      }\n      if (geoInfo.material && geoInfo.material.mappingType !== \"AllSame\") {\n        buffers.materialIndex.push(materialIndex);\n        buffers.materialIndex.push(materialIndex);\n        buffers.materialIndex.push(materialIndex);\n      }\n      if (geoInfo.normal) {\n        buffers.normal.push(faceNormals[0]);\n        buffers.normal.push(faceNormals[1]);\n        buffers.normal.push(faceNormals[2]);\n        buffers.normal.push(faceNormals[(i - 1) * 3]);\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 1]);\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 2]);\n        buffers.normal.push(faceNormals[i * 3]);\n        buffers.normal.push(faceNormals[i * 3 + 1]);\n        buffers.normal.push(faceNormals[i * 3 + 2]);\n      }\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function(uv, j) {\n          if (buffers.uvs[j] === void 0)\n            buffers.uvs[j] = [];\n          buffers.uvs[j].push(faceUVs[j][0]);\n          buffers.uvs[j].push(faceUVs[j][1]);\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);\n          buffers.uvs[j].push(faceUVs[j][i * 2]);\n          buffers.uvs[j].push(faceUVs[j][i * 2 + 1]);\n        });\n      }\n    }\n  }\n  addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {\n    if (morphTargets.length === 0)\n      return;\n    parentGeo.morphTargetsRelative = true;\n    parentGeo.morphAttributes.position = [];\n    const scope = this;\n    morphTargets.forEach(function(morphTarget) {\n      morphTarget.rawTargets.forEach(function(rawTarget) {\n        const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];\n        if (morphGeoNode !== void 0) {\n          scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);\n        }\n      });\n    });\n  }\n  // a morph geometry node is similar to a standard  node, and the node is also contained\n  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n  // and a special attribute Index defining which vertices of the original geometry are affected\n  // Normal and position attributes only have data for the vertices that are affected by the morph\n  genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {\n    const vertexIndices = parentGeoNode.PolygonVertexIndex !== void 0 ? parentGeoNode.PolygonVertexIndex.a : [];\n    const morphPositionsSparse = morphGeoNode.Vertices !== void 0 ? morphGeoNode.Vertices.a : [];\n    const indices = morphGeoNode.Indexes !== void 0 ? morphGeoNode.Indexes.a : [];\n    const length = parentGeo.attributes.position.count * 3;\n    const morphPositions = new Float32Array(length);\n    for (let i = 0; i < indices.length; i++) {\n      const morphIndex = indices[i] * 3;\n      morphPositions[morphIndex] = morphPositionsSparse[i * 3];\n      morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];\n      morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];\n    }\n    const morphGeoInfo = {\n      vertexIndices,\n      vertexPositions: morphPositions\n    };\n    const morphBuffers = this.genBuffers(morphGeoInfo);\n    const positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3);\n    positionAttribute.name = name || morphGeoNode.attrName;\n    positionAttribute.applyMatrix4(preTransform);\n    parentGeo.morphAttributes.position.push(positionAttribute);\n  }\n  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n  parseNormals(NormalNode) {\n    const mappingType = NormalNode.MappingInformationType;\n    const referenceType = NormalNode.ReferenceInformationType;\n    const buffer = NormalNode.Normals.a;\n    let indexBuffer = [];\n    if (referenceType === \"IndexToDirect\") {\n      if (\"NormalIndex\" in NormalNode) {\n        indexBuffer = NormalNode.NormalIndex.a;\n      } else if (\"NormalsIndex\" in NormalNode) {\n        indexBuffer = NormalNode.NormalsIndex.a;\n      }\n    }\n    return {\n      dataSize: 3,\n      buffer,\n      indices: indexBuffer,\n      mappingType,\n      referenceType\n    };\n  }\n  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n  parseUVs(UVNode) {\n    const mappingType = UVNode.MappingInformationType;\n    const referenceType = UVNode.ReferenceInformationType;\n    const buffer = UVNode.UV.a;\n    let indexBuffer = [];\n    if (referenceType === \"IndexToDirect\") {\n      indexBuffer = UVNode.UVIndex.a;\n    }\n    return {\n      dataSize: 2,\n      buffer,\n      indices: indexBuffer,\n      mappingType,\n      referenceType\n    };\n  }\n  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n  parseVertexColors(ColorNode) {\n    const mappingType = ColorNode.MappingInformationType;\n    const referenceType = ColorNode.ReferenceInformationType;\n    const buffer = ColorNode.Colors.a;\n    let indexBuffer = [];\n    if (referenceType === \"IndexToDirect\") {\n      indexBuffer = ColorNode.ColorIndex.a;\n    }\n    return {\n      dataSize: 4,\n      buffer,\n      indices: indexBuffer,\n      mappingType,\n      referenceType\n    };\n  }\n  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n  parseMaterialIndices(MaterialNode) {\n    const mappingType = MaterialNode.MappingInformationType;\n    const referenceType = MaterialNode.ReferenceInformationType;\n    if (mappingType === \"NoMappingInformation\") {\n      return {\n        dataSize: 1,\n        buffer: [0],\n        indices: [0],\n        mappingType: \"AllSame\",\n        referenceType\n      };\n    }\n    const materialIndexBuffer = MaterialNode.Materials.a;\n    const materialIndices = [];\n    for (let i = 0; i < materialIndexBuffer.length; ++i) {\n      materialIndices.push(i);\n    }\n    return {\n      dataSize: 1,\n      buffer: materialIndexBuffer,\n      indices: materialIndices,\n      mappingType,\n      referenceType\n    };\n  }\n  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n  parseNurbsGeometry(geoNode) {\n    if (NURBSCurve === void 0) {\n      console.error(\n        \"THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.\"\n      );\n      return new BufferGeometry();\n    }\n    const order = parseInt(geoNode.Order);\n    if (isNaN(order)) {\n      console.error(\"THREE.FBXLoader: Invalid Order %s given for geometry ID: %s\", geoNode.Order, geoNode.id);\n      return new BufferGeometry();\n    }\n    const degree = order - 1;\n    const knots = geoNode.KnotVector.a;\n    const controlPoints = [];\n    const pointsValues = geoNode.Points.a;\n    for (let i = 0, l = pointsValues.length; i < l; i += 4) {\n      controlPoints.push(new Vector4().fromArray(pointsValues, i));\n    }\n    let startKnot, endKnot;\n    if (geoNode.Form === \"Closed\") {\n      controlPoints.push(controlPoints[0]);\n    } else if (geoNode.Form === \"Periodic\") {\n      startKnot = degree;\n      endKnot = knots.length - 1 - startKnot;\n      for (let i = 0; i < degree; ++i) {\n        controlPoints.push(controlPoints[i]);\n      }\n    }\n    const curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);\n    const points = curve.getPoints(controlPoints.length * 12);\n    return new BufferGeometry().setFromPoints(points);\n  }\n}\nclass AnimationParser {\n  // take raw animation clips and turn them into three.js animation clips\n  parse() {\n    const animationClips = [];\n    const rawClips = this.parseClips();\n    if (rawClips !== void 0) {\n      for (const key in rawClips) {\n        const rawClip = rawClips[key];\n        const clip = this.addClip(rawClip);\n        animationClips.push(clip);\n      }\n    }\n    return animationClips;\n  }\n  parseClips() {\n    if (fbxTree.Objects.AnimationCurve === void 0)\n      return void 0;\n    const curveNodesMap = this.parseAnimationCurveNodes();\n    this.parseAnimationCurves(curveNodesMap);\n    const layersMap = this.parseAnimationLayers(curveNodesMap);\n    const rawClips = this.parseAnimStacks(layersMap);\n    return rawClips;\n  }\n  // parse nodes in FBXTree.Objects.AnimationCurveNode\n  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n  // and is referenced by an AnimationLayer\n  parseAnimationCurveNodes() {\n    const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;\n    const curveNodesMap = /* @__PURE__ */ new Map();\n    for (const nodeID in rawCurveNodes) {\n      const rawCurveNode = rawCurveNodes[nodeID];\n      if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {\n        const curveNode = {\n          id: rawCurveNode.id,\n          attr: rawCurveNode.attrName,\n          curves: {}\n        };\n        curveNodesMap.set(curveNode.id, curveNode);\n      }\n    }\n    return curveNodesMap;\n  }\n  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n  // axis ( e.g. times and values of x rotation)\n  parseAnimationCurves(curveNodesMap) {\n    const rawCurves = fbxTree.Objects.AnimationCurve;\n    for (const nodeID in rawCurves) {\n      const animationCurve = {\n        id: rawCurves[nodeID].id,\n        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),\n        values: rawCurves[nodeID].KeyValueFloat.a\n      };\n      const relationships = connections.get(animationCurve.id);\n      if (relationships !== void 0) {\n        const animationCurveID = relationships.parents[0].ID;\n        const animationCurveRelationship = relationships.parents[0].relationship;\n        if (animationCurveRelationship.match(/X/)) {\n          curveNodesMap.get(animationCurveID).curves[\"x\"] = animationCurve;\n        } else if (animationCurveRelationship.match(/Y/)) {\n          curveNodesMap.get(animationCurveID).curves[\"y\"] = animationCurve;\n        } else if (animationCurveRelationship.match(/Z/)) {\n          curveNodesMap.get(animationCurveID).curves[\"z\"] = animationCurve;\n        } else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {\n          curveNodesMap.get(animationCurveID).curves[\"morph\"] = animationCurve;\n        }\n      }\n    }\n  }\n  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n  // to various AnimationCurveNodes and is referenced by an AnimationStack node\n  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n  parseAnimationLayers(curveNodesMap) {\n    const rawLayers = fbxTree.Objects.AnimationLayer;\n    const layersMap = /* @__PURE__ */ new Map();\n    for (const nodeID in rawLayers) {\n      const layerCurveNodes = [];\n      const connection = connections.get(parseInt(nodeID));\n      if (connection !== void 0) {\n        const children = connection.children;\n        children.forEach(function(child, i) {\n          if (curveNodesMap.has(child.ID)) {\n            const curveNode = curveNodesMap.get(child.ID);\n            if (curveNode.curves.x !== void 0 || curveNode.curves.y !== void 0 || curveNode.curves.z !== void 0) {\n              if (layerCurveNodes[i] === void 0) {\n                const modelID = connections.get(child.ID).parents.filter(function(parent) {\n                  return parent.relationship !== void 0;\n                })[0].ID;\n                if (modelID !== void 0) {\n                  const rawModel = fbxTree.Objects.Model[modelID.toString()];\n                  if (rawModel === void 0) {\n                    console.warn(\"THREE.FBXLoader: Encountered a unused curve.\", child);\n                    return;\n                  }\n                  const node = {\n                    modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : \"\",\n                    ID: rawModel.id,\n                    initialPosition: [0, 0, 0],\n                    initialRotation: [0, 0, 0],\n                    initialScale: [1, 1, 1]\n                  };\n                  sceneGraph.traverse(function(child2) {\n                    if (child2.ID === rawModel.id) {\n                      node.transform = child2.matrix;\n                      if (child2.userData.transformData)\n                        node.eulerOrder = child2.userData.transformData.eulerOrder;\n                    }\n                  });\n                  if (!node.transform)\n                    node.transform = new Matrix4();\n                  if (\"PreRotation\" in rawModel)\n                    node.preRotation = rawModel.PreRotation.value;\n                  if (\"PostRotation\" in rawModel)\n                    node.postRotation = rawModel.PostRotation.value;\n                  layerCurveNodes[i] = node;\n                }\n              }\n              if (layerCurveNodes[i])\n                layerCurveNodes[i][curveNode.attr] = curveNode;\n            } else if (curveNode.curves.morph !== void 0) {\n              if (layerCurveNodes[i] === void 0) {\n                const deformerID = connections.get(child.ID).parents.filter(function(parent) {\n                  return parent.relationship !== void 0;\n                })[0].ID;\n                const morpherID = connections.get(deformerID).parents[0].ID;\n                const geoID = connections.get(morpherID).parents[0].ID;\n                const modelID = connections.get(geoID).parents[0].ID;\n                const rawModel = fbxTree.Objects.Model[modelID];\n                const node = {\n                  modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : \"\",\n                  morphName: fbxTree.Objects.Deformer[deformerID].attrName\n                };\n                layerCurveNodes[i] = node;\n              }\n              layerCurveNodes[i][curveNode.attr] = curveNode;\n            }\n          }\n        });\n        layersMap.set(parseInt(nodeID), layerCurveNodes);\n      }\n    }\n    return layersMap;\n  }\n  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n  // hierarchy. Each Stack node will be used to create a AnimationClip\n  parseAnimStacks(layersMap) {\n    const rawStacks = fbxTree.Objects.AnimationStack;\n    const rawClips = {};\n    for (const nodeID in rawStacks) {\n      const children = connections.get(parseInt(nodeID)).children;\n      if (children.length > 1) {\n        console.warn(\n          \"THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.\"\n        );\n      }\n      const layer = layersMap.get(children[0].ID);\n      rawClips[nodeID] = {\n        name: rawStacks[nodeID].attrName,\n        layer\n      };\n    }\n    return rawClips;\n  }\n  addClip(rawClip) {\n    let tracks = [];\n    const scope = this;\n    rawClip.layer.forEach(function(rawTracks) {\n      tracks = tracks.concat(scope.generateTracks(rawTracks));\n    });\n    return new AnimationClip(rawClip.name, -1, tracks);\n  }\n  generateTracks(rawTracks) {\n    const tracks = [];\n    let initialPosition = new Vector3();\n    let initialRotation = new Quaternion();\n    let initialScale = new Vector3();\n    if (rawTracks.transform)\n      rawTracks.transform.decompose(initialPosition, initialRotation, initialScale);\n    initialPosition = initialPosition.toArray();\n    initialRotation = new Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray();\n    initialScale = initialScale.toArray();\n    if (rawTracks.T !== void 0 && Object.keys(rawTracks.T.curves).length > 0) {\n      const positionTrack = this.generateVectorTrack(\n        rawTracks.modelName,\n        rawTracks.T.curves,\n        initialPosition,\n        \"position\"\n      );\n      if (positionTrack !== void 0)\n        tracks.push(positionTrack);\n    }\n    if (rawTracks.R !== void 0 && Object.keys(rawTracks.R.curves).length > 0) {\n      const rotationTrack = this.generateRotationTrack(\n        rawTracks.modelName,\n        rawTracks.R.curves,\n        initialRotation,\n        rawTracks.preRotation,\n        rawTracks.postRotation,\n        rawTracks.eulerOrder\n      );\n      if (rotationTrack !== void 0)\n        tracks.push(rotationTrack);\n    }\n    if (rawTracks.S !== void 0 && Object.keys(rawTracks.S.curves).length > 0) {\n      const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, \"scale\");\n      if (scaleTrack !== void 0)\n        tracks.push(scaleTrack);\n    }\n    if (rawTracks.DeformPercent !== void 0) {\n      const morphTrack = this.generateMorphTrack(rawTracks);\n      if (morphTrack !== void 0)\n        tracks.push(morphTrack);\n    }\n    return tracks;\n  }\n  generateVectorTrack(modelName, curves, initialValue, type) {\n    const times = this.getTimesForAllAxes(curves);\n    const values = this.getKeyframeTrackValues(times, curves, initialValue);\n    return new VectorKeyframeTrack(modelName + \".\" + type, times, values);\n  }\n  generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {\n    if (curves.x !== void 0) {\n      this.interpolateRotations(curves.x);\n      curves.x.values = curves.x.values.map(MathUtils.degToRad);\n    }\n    if (curves.y !== void 0) {\n      this.interpolateRotations(curves.y);\n      curves.y.values = curves.y.values.map(MathUtils.degToRad);\n    }\n    if (curves.z !== void 0) {\n      this.interpolateRotations(curves.z);\n      curves.z.values = curves.z.values.map(MathUtils.degToRad);\n    }\n    const times = this.getTimesForAllAxes(curves);\n    const values = this.getKeyframeTrackValues(times, curves, initialValue);\n    if (preRotation !== void 0) {\n      preRotation = preRotation.map(MathUtils.degToRad);\n      preRotation.push(eulerOrder);\n      preRotation = new Euler().fromArray(preRotation);\n      preRotation = new Quaternion().setFromEuler(preRotation);\n    }\n    if (postRotation !== void 0) {\n      postRotation = postRotation.map(MathUtils.degToRad);\n      postRotation.push(eulerOrder);\n      postRotation = new Euler().fromArray(postRotation);\n      postRotation = new Quaternion().setFromEuler(postRotation).invert();\n    }\n    const quaternion = new Quaternion();\n    const euler = new Euler();\n    const quaternionValues = [];\n    for (let i = 0; i < values.length; i += 3) {\n      euler.set(values[i], values[i + 1], values[i + 2], eulerOrder);\n      quaternion.setFromEuler(euler);\n      if (preRotation !== void 0)\n        quaternion.premultiply(preRotation);\n      if (postRotation !== void 0)\n        quaternion.multiply(postRotation);\n      quaternion.toArray(quaternionValues, i / 3 * 4);\n    }\n    return new QuaternionKeyframeTrack(modelName + \".quaternion\", times, quaternionValues);\n  }\n  generateMorphTrack(rawTracks) {\n    const curves = rawTracks.DeformPercent.curves.morph;\n    const values = curves.values.map(function(val) {\n      return val / 100;\n    });\n    const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];\n    return new NumberKeyframeTrack(\n      rawTracks.modelName + \".morphTargetInfluences[\" + morphNum + \"]\",\n      curves.times,\n      values\n    );\n  }\n  // For all animated objects, times are defined separately for each axis\n  // Here we'll combine the times into one sorted array without duplicates\n  getTimesForAllAxes(curves) {\n    let times = [];\n    if (curves.x !== void 0)\n      times = times.concat(curves.x.times);\n    if (curves.y !== void 0)\n      times = times.concat(curves.y.times);\n    if (curves.z !== void 0)\n      times = times.concat(curves.z.times);\n    times = times.sort(function(a, b) {\n      return a - b;\n    });\n    if (times.length > 1) {\n      let targetIndex = 1;\n      let lastValue = times[0];\n      for (let i = 1; i < times.length; i++) {\n        const currentValue = times[i];\n        if (currentValue !== lastValue) {\n          times[targetIndex] = currentValue;\n          lastValue = currentValue;\n          targetIndex++;\n        }\n      }\n      times = times.slice(0, targetIndex);\n    }\n    return times;\n  }\n  getKeyframeTrackValues(times, curves, initialValue) {\n    const prevValue = initialValue;\n    const values = [];\n    let xIndex = -1;\n    let yIndex = -1;\n    let zIndex = -1;\n    times.forEach(function(time) {\n      if (curves.x)\n        xIndex = curves.x.times.indexOf(time);\n      if (curves.y)\n        yIndex = curves.y.times.indexOf(time);\n      if (curves.z)\n        zIndex = curves.z.times.indexOf(time);\n      if (xIndex !== -1) {\n        const xValue = curves.x.values[xIndex];\n        values.push(xValue);\n        prevValue[0] = xValue;\n      } else {\n        values.push(prevValue[0]);\n      }\n      if (yIndex !== -1) {\n        const yValue = curves.y.values[yIndex];\n        values.push(yValue);\n        prevValue[1] = yValue;\n      } else {\n        values.push(prevValue[1]);\n      }\n      if (zIndex !== -1) {\n        const zValue = curves.z.values[zIndex];\n        values.push(zValue);\n        prevValue[2] = zValue;\n      } else {\n        values.push(prevValue[2]);\n      }\n    });\n    return values;\n  }\n  // Rotations are defined as Euler angles which can have values  of any size\n  // These will be converted to quaternions which don't support values greater than\n  // PI, so we'll interpolate large rotations\n  interpolateRotations(curve) {\n    for (let i = 1; i < curve.values.length; i++) {\n      const initialValue = curve.values[i - 1];\n      const valuesSpan = curve.values[i] - initialValue;\n      const absoluteSpan = Math.abs(valuesSpan);\n      if (absoluteSpan >= 180) {\n        const numSubIntervals = absoluteSpan / 180;\n        const step = valuesSpan / numSubIntervals;\n        let nextValue = initialValue + step;\n        const initialTime = curve.times[i - 1];\n        const timeSpan = curve.times[i] - initialTime;\n        const interval = timeSpan / numSubIntervals;\n        let nextTime = initialTime + interval;\n        const interpolatedTimes = [];\n        const interpolatedValues = [];\n        while (nextTime < curve.times[i]) {\n          interpolatedTimes.push(nextTime);\n          nextTime += interval;\n          interpolatedValues.push(nextValue);\n          nextValue += step;\n        }\n        curve.times = inject(curve.times, i, interpolatedTimes);\n        curve.values = inject(curve.values, i, interpolatedValues);\n      }\n    }\n  }\n}\nclass TextParser {\n  getPrevNode() {\n    return this.nodeStack[this.currentIndent - 2];\n  }\n  getCurrentNode() {\n    return this.nodeStack[this.currentIndent - 1];\n  }\n  getCurrentProp() {\n    return this.currentProp;\n  }\n  pushStack(node) {\n    this.nodeStack.push(node);\n    this.currentIndent += 1;\n  }\n  popStack() {\n    this.nodeStack.pop();\n    this.currentIndent -= 1;\n  }\n  setCurrentProp(val, name) {\n    this.currentProp = val;\n    this.currentPropName = name;\n  }\n  parse(text) {\n    this.currentIndent = 0;\n    this.allNodes = new FBXTree();\n    this.nodeStack = [];\n    this.currentProp = [];\n    this.currentPropName = \"\";\n    const scope = this;\n    const split = text.split(/[\\r\\n]+/);\n    split.forEach(function(line, i) {\n      const matchComment = line.match(/^[\\s\\t]*;/);\n      const matchEmpty = line.match(/^[\\s\\t]*$/);\n      if (matchComment || matchEmpty)\n        return;\n      const matchBeginning = line.match(\"^\\\\t{\" + scope.currentIndent + \"}(\\\\w+):(.*){\", \"\");\n      const matchProperty = line.match(\"^\\\\t{\" + scope.currentIndent + \"}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)\");\n      const matchEnd = line.match(\"^\\\\t{\" + (scope.currentIndent - 1) + \"}}\");\n      if (matchBeginning) {\n        scope.parseNodeBegin(line, matchBeginning);\n      } else if (matchProperty) {\n        scope.parseNodeProperty(line, matchProperty, split[++i]);\n      } else if (matchEnd) {\n        scope.popStack();\n      } else if (line.match(/^[^\\s\\t}]/)) {\n        scope.parseNodePropertyContinued(line);\n      }\n    });\n    return this.allNodes;\n  }\n  parseNodeBegin(line, property) {\n    const nodeName = property[1].trim().replace(/^\"/, \"\").replace(/\"$/, \"\");\n    const nodeAttrs = property[2].split(\",\").map(function(attr) {\n      return attr.trim().replace(/^\"/, \"\").replace(/\"$/, \"\");\n    });\n    const node = { name: nodeName };\n    const attrs = this.parseNodeAttr(nodeAttrs);\n    const currentNode = this.getCurrentNode();\n    if (this.currentIndent === 0) {\n      this.allNodes.add(nodeName, node);\n    } else {\n      if (nodeName in currentNode) {\n        if (nodeName === \"PoseNode\") {\n          currentNode.PoseNode.push(node);\n        } else if (currentNode[nodeName].id !== void 0) {\n          currentNode[nodeName] = {};\n          currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];\n        }\n        if (attrs.id !== \"\")\n          currentNode[nodeName][attrs.id] = node;\n      } else if (typeof attrs.id === \"number\") {\n        currentNode[nodeName] = {};\n        currentNode[nodeName][attrs.id] = node;\n      } else if (nodeName !== \"Properties70\") {\n        if (nodeName === \"PoseNode\")\n          currentNode[nodeName] = [node];\n        else\n          currentNode[nodeName] = node;\n      }\n    }\n    if (typeof attrs.id === \"number\")\n      node.id = attrs.id;\n    if (attrs.name !== \"\")\n      node.attrName = attrs.name;\n    if (attrs.type !== \"\")\n      node.attrType = attrs.type;\n    this.pushStack(node);\n  }\n  parseNodeAttr(attrs) {\n    let id = attrs[0];\n    if (attrs[0] !== \"\") {\n      id = parseInt(attrs[0]);\n      if (isNaN(id)) {\n        id = attrs[0];\n      }\n    }\n    let name = \"\", type = \"\";\n    if (attrs.length > 1) {\n      name = attrs[1].replace(/^(\\w+)::/, \"\");\n      type = attrs[2];\n    }\n    return { id, name, type };\n  }\n  parseNodeProperty(line, property, contentLine) {\n    let propName = property[1].replace(/^\"/, \"\").replace(/\"$/, \"\").trim();\n    let propValue = property[2].replace(/^\"/, \"\").replace(/\"$/, \"\").trim();\n    if (propName === \"Content\" && propValue === \",\") {\n      propValue = contentLine.replace(/\"/g, \"\").replace(/,$/, \"\").trim();\n    }\n    const currentNode = this.getCurrentNode();\n    const parentName = currentNode.name;\n    if (parentName === \"Properties70\") {\n      this.parseNodeSpecialProperty(line, propName, propValue);\n      return;\n    }\n    if (propName === \"C\") {\n      const connProps = propValue.split(\",\").slice(1);\n      const from = parseInt(connProps[0]);\n      const to = parseInt(connProps[1]);\n      let rest = propValue.split(\",\").slice(3);\n      rest = rest.map(function(elem) {\n        return elem.trim().replace(/^\"/, \"\");\n      });\n      propName = \"connections\";\n      propValue = [from, to];\n      append(propValue, rest);\n      if (currentNode[propName] === void 0) {\n        currentNode[propName] = [];\n      }\n    }\n    if (propName === \"Node\")\n      currentNode.id = propValue;\n    if (propName in currentNode && Array.isArray(currentNode[propName])) {\n      currentNode[propName].push(propValue);\n    } else {\n      if (propName !== \"a\")\n        currentNode[propName] = propValue;\n      else\n        currentNode.a = propValue;\n    }\n    this.setCurrentProp(currentNode, propName);\n    if (propName === \"a\" && propValue.slice(-1) !== \",\") {\n      currentNode.a = parseNumberArray(propValue);\n    }\n  }\n  parseNodePropertyContinued(line) {\n    const currentNode = this.getCurrentNode();\n    currentNode.a += line;\n    if (line.slice(-1) !== \",\") {\n      currentNode.a = parseNumberArray(currentNode.a);\n    }\n  }\n  // parse \"Property70\"\n  parseNodeSpecialProperty(line, propName, propValue) {\n    const props = propValue.split('\",').map(function(prop) {\n      return prop.trim().replace(/^\\\"/, \"\").replace(/\\s/, \"_\");\n    });\n    const innerPropName = props[0];\n    const innerPropType1 = props[1];\n    const innerPropType2 = props[2];\n    const innerPropFlag = props[3];\n    let innerPropValue = props[4];\n    switch (innerPropType1) {\n      case \"int\":\n      case \"enum\":\n      case \"bool\":\n      case \"ULongLong\":\n      case \"double\":\n      case \"Number\":\n      case \"FieldOfView\":\n        innerPropValue = parseFloat(innerPropValue);\n        break;\n      case \"Color\":\n      case \"ColorRGB\":\n      case \"Vector3D\":\n      case \"Lcl_Translation\":\n      case \"Lcl_Rotation\":\n      case \"Lcl_Scaling\":\n        innerPropValue = parseNumberArray(innerPropValue);\n        break;\n    }\n    this.getPrevNode()[innerPropName] = {\n      type: innerPropType1,\n      type2: innerPropType2,\n      flag: innerPropFlag,\n      value: innerPropValue\n    };\n    this.setCurrentProp(this.getPrevNode(), innerPropName);\n  }\n}\nclass BinaryParser {\n  parse(buffer) {\n    const reader = new BinaryReader(buffer);\n    reader.skip(23);\n    const version = reader.getUint32();\n    if (version < 6400) {\n      throw new Error(\"THREE.FBXLoader: FBX version not supported, FileVersion: \" + version);\n    }\n    const allNodes = new FBXTree();\n    while (!this.endOfContent(reader)) {\n      const node = this.parseNode(reader, version);\n      if (node !== null)\n        allNodes.add(node.name, node);\n    }\n    return allNodes;\n  }\n  // Check if reader has reached the end of content.\n  endOfContent(reader) {\n    if (reader.size() % 16 === 0) {\n      return (reader.getOffset() + 160 + 16 & ~15) >= reader.size();\n    } else {\n      return reader.getOffset() + 160 + 16 >= reader.size();\n    }\n  }\n  // recursively parse nodes until the end of the file is reached\n  parseNode(reader, version) {\n    const node = {};\n    const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();\n    const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();\n    version >= 7500 ? reader.getUint64() : reader.getUint32();\n    const nameLen = reader.getUint8();\n    const name = reader.getString(nameLen);\n    if (endOffset === 0)\n      return null;\n    const propertyList = [];\n    for (let i = 0; i < numProperties; i++) {\n      propertyList.push(this.parseProperty(reader));\n    }\n    const id = propertyList.length > 0 ? propertyList[0] : \"\";\n    const attrName = propertyList.length > 1 ? propertyList[1] : \"\";\n    const attrType = propertyList.length > 2 ? propertyList[2] : \"\";\n    node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;\n    while (endOffset > reader.getOffset()) {\n      const subNode = this.parseNode(reader, version);\n      if (subNode !== null)\n        this.parseSubNode(name, node, subNode);\n    }\n    node.propertyList = propertyList;\n    if (typeof id === \"number\")\n      node.id = id;\n    if (attrName !== \"\")\n      node.attrName = attrName;\n    if (attrType !== \"\")\n      node.attrType = attrType;\n    if (name !== \"\")\n      node.name = name;\n    return node;\n  }\n  parseSubNode(name, node, subNode) {\n    if (subNode.singleProperty === true) {\n      const value = subNode.propertyList[0];\n      if (Array.isArray(value)) {\n        node[subNode.name] = subNode;\n        subNode.a = value;\n      } else {\n        node[subNode.name] = value;\n      }\n    } else if (name === \"Connections\" && subNode.name === \"C\") {\n      const array = [];\n      subNode.propertyList.forEach(function(property, i) {\n        if (i !== 0)\n          array.push(property);\n      });\n      if (node.connections === void 0) {\n        node.connections = [];\n      }\n      node.connections.push(array);\n    } else if (subNode.name === \"Properties70\") {\n      const keys = Object.keys(subNode);\n      keys.forEach(function(key) {\n        node[key] = subNode[key];\n      });\n    } else if (name === \"Properties70\" && subNode.name === \"P\") {\n      let innerPropName = subNode.propertyList[0];\n      let innerPropType1 = subNode.propertyList[1];\n      const innerPropType2 = subNode.propertyList[2];\n      const innerPropFlag = subNode.propertyList[3];\n      let innerPropValue;\n      if (innerPropName.indexOf(\"Lcl \") === 0)\n        innerPropName = innerPropName.replace(\"Lcl \", \"Lcl_\");\n      if (innerPropType1.indexOf(\"Lcl \") === 0)\n        innerPropType1 = innerPropType1.replace(\"Lcl \", \"Lcl_\");\n      if (innerPropType1 === \"Color\" || innerPropType1 === \"ColorRGB\" || innerPropType1 === \"Vector\" || innerPropType1 === \"Vector3D\" || innerPropType1.indexOf(\"Lcl_\") === 0) {\n        innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];\n      } else {\n        innerPropValue = subNode.propertyList[4];\n      }\n      node[innerPropName] = {\n        type: innerPropType1,\n        type2: innerPropType2,\n        flag: innerPropFlag,\n        value: innerPropValue\n      };\n    } else if (node[subNode.name] === void 0) {\n      if (typeof subNode.id === \"number\") {\n        node[subNode.name] = {};\n        node[subNode.name][subNode.id] = subNode;\n      } else {\n        node[subNode.name] = subNode;\n      }\n    } else {\n      if (subNode.name === \"PoseNode\") {\n        if (!Array.isArray(node[subNode.name])) {\n          node[subNode.name] = [node[subNode.name]];\n        }\n        node[subNode.name].push(subNode);\n      } else if (node[subNode.name][subNode.id] === void 0) {\n        node[subNode.name][subNode.id] = subNode;\n      }\n    }\n  }\n  parseProperty(reader) {\n    const type = reader.getString(1);\n    let length;\n    switch (type) {\n      case \"C\":\n        return reader.getBoolean();\n      case \"D\":\n        return reader.getFloat64();\n      case \"F\":\n        return reader.getFloat32();\n      case \"I\":\n        return reader.getInt32();\n      case \"L\":\n        return reader.getInt64();\n      case \"R\":\n        length = reader.getUint32();\n        return reader.getArrayBuffer(length);\n      case \"S\":\n        length = reader.getUint32();\n        return reader.getString(length);\n      case \"Y\":\n        return reader.getInt16();\n      case \"b\":\n      case \"c\":\n      case \"d\":\n      case \"f\":\n      case \"i\":\n      case \"l\":\n        const arrayLength = reader.getUint32();\n        const encoding = reader.getUint32();\n        const compressedLength = reader.getUint32();\n        if (encoding === 0) {\n          switch (type) {\n            case \"b\":\n            case \"c\":\n              return reader.getBooleanArray(arrayLength);\n            case \"d\":\n              return reader.getFloat64Array(arrayLength);\n            case \"f\":\n              return reader.getFloat32Array(arrayLength);\n            case \"i\":\n              return reader.getInt32Array(arrayLength);\n            case \"l\":\n              return reader.getInt64Array(arrayLength);\n          }\n        }\n        const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)));\n        const reader2 = new BinaryReader(data.buffer);\n        switch (type) {\n          case \"b\":\n          case \"c\":\n            return reader2.getBooleanArray(arrayLength);\n          case \"d\":\n            return reader2.getFloat64Array(arrayLength);\n          case \"f\":\n            return reader2.getFloat32Array(arrayLength);\n          case \"i\":\n            return reader2.getInt32Array(arrayLength);\n          case \"l\":\n            return reader2.getInt64Array(arrayLength);\n        }\n      default:\n        throw new Error(\"THREE.FBXLoader: Unknown property type \" + type);\n    }\n  }\n}\nclass BinaryReader {\n  constructor(buffer, littleEndian) {\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this.littleEndian = littleEndian !== void 0 ? littleEndian : true;\n  }\n  getOffset() {\n    return this.offset;\n  }\n  size() {\n    return this.dv.buffer.byteLength;\n  }\n  skip(length) {\n    this.offset += length;\n  }\n  // seems like true/false representation depends on exporter.\n  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n  // then sees LSB.\n  getBoolean() {\n    return (this.getUint8() & 1) === 1;\n  }\n  getBooleanArray(size) {\n    const a = [];\n    for (let i = 0; i < size; i++) {\n      a.push(this.getBoolean());\n    }\n    return a;\n  }\n  getUint8() {\n    const value = this.dv.getUint8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n  getInt16() {\n    const value = this.dv.getInt16(this.offset, this.littleEndian);\n    this.offset += 2;\n    return value;\n  }\n  getInt32() {\n    const value = this.dv.getInt32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  }\n  getInt32Array(size) {\n    const a = [];\n    for (let i = 0; i < size; i++) {\n      a.push(this.getInt32());\n    }\n    return a;\n  }\n  getUint32() {\n    const value = this.dv.getUint32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  }\n  // JavaScript doesn't support 64-bit integer so calculate this here\n  // 1 << 32 will return 1 so using multiply operation instead here.\n  // There's a possibility that this method returns wrong value if the value\n  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n  // TODO: safely handle 64-bit integer\n  getInt64() {\n    let low, high;\n    if (this.littleEndian) {\n      low = this.getUint32();\n      high = this.getUint32();\n    } else {\n      high = this.getUint32();\n      low = this.getUint32();\n    }\n    if (high & 2147483648) {\n      high = ~high & 4294967295;\n      low = ~low & 4294967295;\n      if (low === 4294967295)\n        high = high + 1 & 4294967295;\n      low = low + 1 & 4294967295;\n      return -(high * 4294967296 + low);\n    }\n    return high * 4294967296 + low;\n  }\n  getInt64Array(size) {\n    const a = [];\n    for (let i = 0; i < size; i++) {\n      a.push(this.getInt64());\n    }\n    return a;\n  }\n  // Note: see getInt64() comment\n  getUint64() {\n    let low, high;\n    if (this.littleEndian) {\n      low = this.getUint32();\n      high = this.getUint32();\n    } else {\n      high = this.getUint32();\n      low = this.getUint32();\n    }\n    return high * 4294967296 + low;\n  }\n  getFloat32() {\n    const value = this.dv.getFloat32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  }\n  getFloat32Array(size) {\n    const a = [];\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat32());\n    }\n    return a;\n  }\n  getFloat64() {\n    const value = this.dv.getFloat64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n  getFloat64Array(size) {\n    const a = [];\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat64());\n    }\n    return a;\n  }\n  getArrayBuffer(size) {\n    const value = this.dv.buffer.slice(this.offset, this.offset + size);\n    this.offset += size;\n    return value;\n  }\n  getString(size) {\n    let a = [];\n    for (let i = 0; i < size; i++) {\n      a[i] = this.getUint8();\n    }\n    const nullByte = a.indexOf(0);\n    if (nullByte >= 0)\n      a = a.slice(0, nullByte);\n    return decodeText(new Uint8Array(a));\n  }\n}\nclass FBXTree {\n  add(key, val) {\n    this[key] = val;\n  }\n}\nfunction isFbxFormatBinary(buffer) {\n  const CORRECT = \"Kaydara FBX Binary  \\0\";\n  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);\n}\nfunction isFbxFormatASCII(text) {\n  const CORRECT = [\n    \"K\",\n    \"a\",\n    \"y\",\n    \"d\",\n    \"a\",\n    \"r\",\n    \"a\",\n    \"\\\\\",\n    \"F\",\n    \"B\",\n    \"X\",\n    \"\\\\\",\n    \"B\",\n    \"i\",\n    \"n\",\n    \"a\",\n    \"r\",\n    \"y\",\n    \"\\\\\",\n    \"\\\\\"\n  ];\n  let cursor = 0;\n  function read(offset) {\n    const result = text[offset - 1];\n    text = text.slice(cursor + offset);\n    cursor++;\n    return result;\n  }\n  for (let i = 0; i < CORRECT.length; ++i) {\n    const num = read(1);\n    if (num === CORRECT[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getFbxVersion(text) {\n  const versionRegExp = /FBXVersion: (\\d+)/;\n  const match = text.match(versionRegExp);\n  if (match) {\n    const version = parseInt(match[1]);\n    return version;\n  }\n  throw new Error(\"THREE.FBXLoader: Cannot find the version number for the file given.\");\n}\nfunction convertFBXTimeToSeconds(time) {\n  return time / 46186158e3;\n}\nconst dataArray = [];\nfunction getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n  let index;\n  switch (infoObject.mappingType) {\n    case \"ByPolygonVertex\":\n      index = polygonVertexIndex;\n      break;\n    case \"ByPolygon\":\n      index = polygonIndex;\n      break;\n    case \"ByVertice\":\n      index = vertexIndex;\n      break;\n    case \"AllSame\":\n      index = infoObject.indices[0];\n      break;\n    default:\n      console.warn(\"THREE.FBXLoader: unknown attribute mapping type \" + infoObject.mappingType);\n  }\n  if (infoObject.referenceType === \"IndexToDirect\")\n    index = infoObject.indices[index];\n  const from = index * infoObject.dataSize;\n  const to = from + infoObject.dataSize;\n  return slice(dataArray, infoObject.buffer, from, to);\n}\nconst tempEuler = /* @__PURE__ */ new Euler();\nconst tempVec = /* @__PURE__ */ new Vector3();\nfunction generateTransform(transformData) {\n  const lTranslationM = new Matrix4();\n  const lPreRotationM = new Matrix4();\n  const lRotationM = new Matrix4();\n  const lPostRotationM = new Matrix4();\n  const lScalingM = new Matrix4();\n  const lScalingPivotM = new Matrix4();\n  const lScalingOffsetM = new Matrix4();\n  const lRotationOffsetM = new Matrix4();\n  const lRotationPivotM = new Matrix4();\n  const lParentGX = new Matrix4();\n  const lParentLX = new Matrix4();\n  const lGlobalT = new Matrix4();\n  const inheritType = transformData.inheritType ? transformData.inheritType : 0;\n  if (transformData.translation)\n    lTranslationM.setPosition(tempVec.fromArray(transformData.translation));\n  if (transformData.preRotation) {\n    const array = transformData.preRotation.map(MathUtils.degToRad);\n    array.push(transformData.eulerOrder);\n    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\n  }\n  if (transformData.rotation) {\n    const array = transformData.rotation.map(MathUtils.degToRad);\n    array.push(transformData.eulerOrder);\n    lRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\n  }\n  if (transformData.postRotation) {\n    const array = transformData.postRotation.map(MathUtils.degToRad);\n    array.push(transformData.eulerOrder);\n    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\n    lPostRotationM.invert();\n  }\n  if (transformData.scale)\n    lScalingM.scale(tempVec.fromArray(transformData.scale));\n  if (transformData.scalingOffset)\n    lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));\n  if (transformData.scalingPivot)\n    lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));\n  if (transformData.rotationOffset)\n    lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));\n  if (transformData.rotationPivot)\n    lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot));\n  if (transformData.parentMatrixWorld) {\n    lParentLX.copy(transformData.parentMatrix);\n    lParentGX.copy(transformData.parentMatrixWorld);\n  }\n  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM);\n  const lParentGRM = new Matrix4();\n  lParentGRM.extractRotation(lParentGX);\n  const lParentTM = new Matrix4();\n  lParentTM.copyPosition(lParentGX);\n  const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);\n  const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);\n  const lLSM = lScalingM;\n  const lGlobalRS = new Matrix4();\n  if (inheritType === 0) {\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);\n  } else if (inheritType === 1) {\n    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);\n  } else {\n    const lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX));\n    const lParentLSM_inv = lParentLSM.clone().invert();\n    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);\n  }\n  const lRotationPivotM_inv = lRotationPivotM.clone().invert();\n  const lScalingPivotM_inv = lScalingPivotM.clone().invert();\n  let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);\n  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform);\n  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);\n  lGlobalT.copyPosition(lGlobalTranslation);\n  lTransform = lGlobalT.clone().multiply(lGlobalRS);\n  lTransform.premultiply(lParentGX.invert());\n  return lTransform;\n}\nfunction getEulerOrder(order) {\n  order = order || 0;\n  const enums = [\n    \"ZYX\",\n    // -> XYZ extrinsic\n    \"YZX\",\n    // -> XZY extrinsic\n    \"XZY\",\n    // -> YZX extrinsic\n    \"ZXY\",\n    // -> YXZ extrinsic\n    \"YXZ\",\n    // -> ZXY extrinsic\n    \"XYZ\"\n    // -> ZYX extrinsic\n    //'SphericXYZ', // not possible to support\n  ];\n  if (order === 6) {\n    console.warn(\"THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.\");\n    return enums[0];\n  }\n  return enums[order];\n}\nfunction parseNumberArray(value) {\n  const array = value.split(\",\").map(function(val) {\n    return parseFloat(val);\n  });\n  return array;\n}\nfunction convertArrayBufferToString(buffer, from, to) {\n  if (from === void 0)\n    from = 0;\n  if (to === void 0)\n    to = buffer.byteLength;\n  return decodeText(new Uint8Array(buffer, from, to));\n}\nfunction append(a, b) {\n  for (let i = 0, j = a.length, l = b.length; i < l; i++, j++) {\n    a[j] = b[i];\n  }\n}\nfunction slice(a, b, from, to) {\n  for (let i = from, j = 0; i < to; i++, j++) {\n    a[j] = b[i];\n  }\n  return a;\n}\nfunction inject(a1, index, a2) {\n  return a1.slice(0, index).concat(a2).concat(a1.slice(index));\n}\nexport {\n  FBXLoader\n};\n//# sourceMappingURL=FBXLoader.js.map\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { FBXLoader } from 'three-stdlib';\nimport { useLoader } from '@react-three/fiber';\nimport { Clone } from './Clone.js';\n\nfunction useFBX(path) {\n  return useLoader(FBXLoader, path);\n}\nuseFBX.preload = path => useLoader.preload(FBXLoader, path);\nuseFBX.clear = input => useLoader.clear(FBXLoader, input);\nfunction Fbx({\n  path,\n  ...props\n}) {\n  const fbx = useFBX(path);\n  const object = fbx.children[0];\n  return /*#__PURE__*/React.createElement(Clone, _extends({}, props, {\n    object: object\n  }));\n}\n\nexport { Fbx, useFBX };\n","import * as React from 'react';\nimport { Object3D, AnimationMixer } from 'three';\nimport { useFrame } from '@react-three/fiber';\n\nfunction useAnimations(clips, root) {\n  const ref = React.useRef(null);\n  const [actualRef] = React.useState(() => root ? root instanceof Object3D ? {\n    current: root\n  } : root : ref);\n  const [mixer] = React.useState(() => new AnimationMixer(undefined));\n  React.useLayoutEffect(() => {\n    if (root) actualRef.current = root instanceof Object3D ? root : root.current;\n    mixer._root = actualRef.current;\n  });\n  const lazyActions = React.useRef({});\n  const api = React.useMemo(() => {\n    const actions = {};\n    clips.forEach(clip => Object.defineProperty(actions, clip.name, {\n      enumerable: true,\n      get() {\n        if (actualRef.current) {\n          return lazyActions.current[clip.name] || (lazyActions.current[clip.name] = mixer.clipAction(clip, actualRef.current));\n        }\n      },\n      configurable: true\n    }));\n    return {\n      ref: actualRef,\n      clips,\n      actions,\n      names: clips.map(c => c.name),\n      mixer\n    };\n  }, [clips]);\n  useFrame((state, delta) => mixer.update(delta));\n  React.useEffect(() => {\n    const currentRoot = actualRef.current;\n    return () => {\n      // Clean up only when clips change, wipe out lazy actions and uncache clips\n      lazyActions.current = {};\n      mixer.stopAllAction();\n      Object.values(api.actions).forEach(action => {\n        if (currentRoot) {\n          mixer.uncacheAction(action, currentRoot);\n        }\n      });\n    };\n  }, [clips]);\n  return api;\n}\n\nexport { useAnimations };\n","import { useAnimations, useFBX, useGLTF } from '@react-three/drei';\r\nimport { useEffect, useRef } from 'react';\r\nimport { useMediaQuery } from 'react-responsive';\r\n\r\nconst ExperienceCanvas = ({ animationName = 'idle', ...props }) => {\r\n  const group = useRef(null);\r\n\r\n  // useGLTF.preload(`${import.meta.env.BASE_URL}/models/3DMe-draco.glb`);\r\n  // useGLTF.preload(`${import.meta.env.BASE_URL}/models/animations/idle.glb`);\r\n  // useGLTF.preload(`${import.meta.env.BASE_URL}/models/animations/salute.glb`);\r\n  // useGLTF.preload(`${import.meta.env.BASE_URL}/models/animations/clapping.glb`);\r\n  // useGLTF.preload(`${import.meta.env.BASE_URL}/models/animations/victory.glb`);\r\n\r\n  // Load model\r\n  const { scene, nodes, materials } = useGLTF(\r\n    `${import.meta.env.BASE_URL}/models/3DMe-draco.glb`\r\n  );\r\n\r\n  // Load animations\r\n  const { animations: idleAnimation } = useFBX(\r\n    `${import.meta.env.BASE_URL}/models/animations/idle.fbx`\r\n  );\r\n  const { animations: saluteAnimation } = useFBX(\r\n    `${import.meta.env.BASE_URL}/models/animations/salute.fbx`\r\n  );\r\n  const { animations: clappingAnimation } = useFBX(\r\n    `${import.meta.env.BASE_URL}/models/animations/clapping.fbx`\r\n  );\r\n  const { animations: victoryAnimation } = useFBX(\r\n    `${import.meta.env.BASE_URL}/models/animations/victory.fbx`\r\n  );\r\n\r\n  const clips = [];\r\n  if (idleAnimation?.[0]) {\r\n    idleAnimation[0].name = 'idle';\r\n    clips.push(idleAnimation[0]);\r\n  }\r\n  if (saluteAnimation?.[0]) {\r\n    saluteAnimation[0].name = 'salute';\r\n    clips.push(saluteAnimation[0]);\r\n  }\r\n  if (clappingAnimation?.[0]) {\r\n    clappingAnimation[0].name = 'clapping';\r\n    clips.push(clappingAnimation[0]);\r\n  }\r\n  if (victoryAnimation?.[0]) {\r\n    victoryAnimation[0].name = 'victory';\r\n    clips.push(victoryAnimation[0]);\r\n  }\r\n  // Bind animations\r\n  const { actions } = useAnimations(clips, group);\r\n\r\n  // Switch animations\r\n  useEffect(() => {\r\n    if (actions && animationName) {\r\n      const action = actions[animationName] || actions['idle'];\r\n\r\n      Object.values(actions).forEach(a => {\r\n        if (a && a !== action) {\r\n          a.fadeOut(0.5);\r\n          a.stop();\r\n        }\r\n      });\r\n\r\n      if (action) {\r\n        action.reset().fadeIn(0.5).play();\r\n      }\r\n\r\n      return () => {\r\n        if (action) action.fadeOut(0.5);\r\n      };\r\n    }\r\n  }, [animationName, actions]);\r\n\r\n  // --- Responsive sizing (built-in) ---\r\n  const isSmall = useMediaQuery({ maxWidth: 480 });\r\n  const isMobile = useMediaQuery({ maxWidth: 768 });\r\n  const isTablet = useMediaQuery({ maxWidth: 1024 });\r\n  const isExtraLarge = useMediaQuery({ minWidth: 1536 });\r\n\r\n  const calculateSizes = () => {\r\n    if (isSmall) return { scale: 1.5, positionY: -2.2 };\r\n    if (isMobile) return { scale: 2, positionY: -2.5 };\r\n    if (isTablet) return { scale: 2.5, positionY: -2.8 };\r\n    if (isExtraLarge) return { scale: 3.5, positionY: -3.2 };\r\n    return { scale: 3, positionY: -3 }; // default desktop\r\n  };\r\n\r\n  const { scale, positionY } = calculateSizes();\r\n\r\n  return (\r\n    <group\r\n      ref={group}\r\n      dispose={null}\r\n      scale={scale}\r\n      position={[0, positionY, 0]}\r\n      {...props}\r\n    >\r\n      <primitive object={scene} />\r\n      <skinnedMesh\r\n        name=\"EyeLeft\"\r\n        geometry={nodes.EyeLeft.geometry}\r\n        material={materials.Wolf3D_Eye}\r\n        skeleton={nodes.EyeLeft.skeleton}\r\n        morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}\r\n        morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}\r\n      />\r\n      <skinnedMesh\r\n        name=\"EyeRight\"\r\n        geometry={nodes.EyeRight.geometry}\r\n        material={materials.Wolf3D_Eye}\r\n        skeleton={nodes.EyeRight.skeleton}\r\n        morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}\r\n        morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}\r\n      />\r\n      <skinnedMesh\r\n        name=\"Wolf3D_Head\"\r\n        geometry={nodes.Wolf3D_Head.geometry}\r\n        material={materials.Wolf3D_Skin}\r\n        skeleton={nodes.Wolf3D_Head.skeleton}\r\n        morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}\r\n        morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}\r\n      />\r\n      <skinnedMesh\r\n        name=\"Wolf3D_Teeth\"\r\n        geometry={nodes.Wolf3D_Teeth.geometry}\r\n        material={materials.Wolf3D_Teeth}\r\n        skeleton={nodes.Wolf3D_Teeth.skeleton}\r\n        morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}\r\n        morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}\r\n      />\r\n      <skinnedMesh\r\n        geometry={nodes.Wolf3D_Hair.geometry}\r\n        material={materials.Wolf3D_Hair}\r\n        skeleton={nodes.Wolf3D_Hair.skeleton}\r\n      />\r\n      <skinnedMesh\r\n        geometry={nodes.Wolf3D_Outfit_Top.geometry}\r\n        material={materials.Wolf3D_Outfit_Top}\r\n        skeleton={nodes.Wolf3D_Outfit_Top.skeleton}\r\n      />\r\n      <skinnedMesh\r\n        geometry={nodes.Wolf3D_Outfit_Bottom.geometry}\r\n        material={materials.Wolf3D_Outfit_Bottom}\r\n        skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}\r\n      />\r\n      <skinnedMesh\r\n        geometry={nodes.Wolf3D_Outfit_Footwear.geometry}\r\n        material={materials.Wolf3D_Outfit_Footwear}\r\n        skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}\r\n      />\r\n      <skinnedMesh\r\n        geometry={nodes.Wolf3D_Body.geometry}\r\n        material={materials.Wolf3D_Body}\r\n        skeleton={nodes.Wolf3D_Body.skeleton}\r\n      />\r\n    </group>\r\n  );\r\n};\r\n\r\nuseGLTF.preload(`${import.meta.env.BASE_URL}/models/3DMe-draco.glb`);\r\n\r\nexport default ExperienceCanvas;\r\n"],"names":["UV1","version","u8","u16","u32","fleb","fdeb","clim","freb","eb","start","b","i","r","j","_a","fl","revfl","_b","fd","rev","x","hMap","cd","mb","s","l","le","co","rvb","sv","r_1","v","m","flt","fdt","flrm","fdrm","max","a","bits","d","p","o","bits16","shft","slc","e","n","inflt","dat","buf","st","sl","noBuf","noSt","cbuf","bl","nbuf","final","pos","bt","lm","dm","lbt","dbt","tbts","type","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","c","lt","dt","t","lms","dms","lpos","sym","add","dsym","end","et","zlv","unzlibSync","data","out","td","tds","findSpan","u","U","low","high","mid","calcBasisFunctions","span","N","left","right","saved","rv","lv","temp","calcBSplinePoint","P","C","Vector4","point","Nj","wNj","calcBasisFunctionDerivatives","zeroArr","ders","ndu","r2","s1","s2","k","rk","pk","j1","j2","j3","calcBSplineDerivatives","nd","du","CK","nders","Pw","w","calcKoverI","nom","denom","calcRationalCurveDerivatives","Pders","Aders","wders","Vector3","calcNURBSDerivatives","NURBSCurve","Curve","degree","knots","controlPoints","startKnot","endKnot","optionalTarget","hpoint","tangent","fbxTree","connections","sceneGraph","FBXLoader","Loader","manager","url","onLoad","onProgress","onError","scope","path","LoaderUtils","loader","FileLoader","buffer","FBXBuffer","isFbxFormatBinary","BinaryParser","FBXText","convertArrayBufferToString","isFbxFormatASCII","getFbxVersion","TextParser","textureLoader","TextureLoader","FBXTreeParser","images","textures","materials","deformers","geometryMap","GeometryParser","connectionMap","rawConnection","fromID","toID","relationship","parentRelationship","childRelationship","blobs","videoNodes","nodeID","videoNode","id","arrayBufferContent","base64Content","image","filename","content","fileName","extension","array","textureMap","textureNodes","texture","textureNode","wrapModeU","wrapModeV","valueU","valueV","RepeatWrapping","ClampToEdgeWrapping","values","currentPath","children","Texture","materialMap","materialNodes","material","materialNode","ID","name","parameters","MeshPhongMaterial","MeshLambertMaterial","Color","child","EquirectangularReflectionMapping","skeletons","morphTargets","DeformerNodes","deformerNode","relationships","skeleton","morphTarget","deformerNodes","rawBones","boneNode","rawBone","Matrix4","rawMorphTargets","morphTargetNode","rawMorphTarget","child2","Group","modelMap","modelNodes","model","modelNode","connection","parent","node","transform","generateTransform","animations","AnimationParser","Bone","PropertyBinding","bone","subBone","cameraAttribute","attr","Object3D","nearClippingPlane","farClippingPlane","width","height","aspect","fov","focalLength","PerspectiveCamera","OrthographicCamera","lightAttribute","color","intensity","distance","decay","PointLight","DirectionalLight","angle","MathUtils","penumbra","SpotLight","geometry","material2","SkinnedMesh","Mesh","geo","LineBasicMaterial","Line","transformData","getEulerOrder","lookAtTarget","bindMatrices","geoID","geoConnParent","Skeleton","BindPoseNode","poseNodes","poseNode","ambientColor","g","AmbientLight","geoNodes","geoNode","skeleton2","preTransform","BufferGeometry","geoInfo","buffers","positionAttribute","Float32BufferAttribute","Uint16BufferAttribute","normalMatrix","Matrix3","normalAttribute","uvBuffer","prevMaterialIndex","startIndex","currentIndex","lastGroup","lastIndex","index","polygonIndex","faceLength","displayedWeightsWarning","facePositionIndexes","faceNormals","faceColors","faceUVs","faceWeights","faceWeightIndices","vertexIndex","polygonVertexIndex","materialIndex","endOfFace","weightIndices","weights","getData","wt","wIndex","Weight","weight","weightIndex","currentWeight","comparedWeight","comparedWeightIndex","comparedWeightArray","tmp","uv","parentGeo","parentGeoNode","rawTarget","morphGeoNode","vertexIndices","morphPositionsSparse","indices","length","morphPositions","morphIndex","morphGeoInfo","morphBuffers","NormalNode","mappingType","referenceType","indexBuffer","UVNode","ColorNode","MaterialNode","materialIndexBuffer","materialIndices","order","pointsValues","points","animationClips","rawClips","key","rawClip","clip","curveNodesMap","layersMap","rawCurveNodes","rawCurveNode","curveNode","rawCurves","animationCurve","convertFBXTimeToSeconds","animationCurveID","animationCurveRelationship","rawLayers","layerCurveNodes","modelID","rawModel","deformerID","morpherID","rawStacks","layer","tracks","rawTracks","AnimationClip","initialPosition","initialRotation","Quaternion","initialScale","Euler","positionTrack","rotationTrack","scaleTrack","morphTrack","modelName","curves","initialValue","times","VectorKeyframeTrack","preRotation","postRotation","eulerOrder","quaternion","euler","quaternionValues","QuaternionKeyframeTrack","val","morphNum","NumberKeyframeTrack","targetIndex","lastValue","currentValue","prevValue","xIndex","yIndex","zIndex","time","xValue","yValue","zValue","curve","valuesSpan","absoluteSpan","numSubIntervals","step","nextValue","initialTime","interval","nextTime","interpolatedTimes","interpolatedValues","inject","text","FBXTree","split","line","matchComment","matchEmpty","matchBeginning","matchProperty","matchEnd","property","nodeName","nodeAttrs","attrs","currentNode","contentLine","propName","propValue","connProps","from","to","rest","elem","append","parseNumberArray","props","prop","innerPropName","innerPropType1","innerPropType2","innerPropFlag","innerPropValue","reader","BinaryReader","allNodes","endOffset","numProperties","nameLen","propertyList","attrName","attrType","subNode","value","arrayLength","encoding","compressedLength","reader2","littleEndian","size","nullByte","decodeText","CORRECT","cursor","read","offset","result","versionRegExp","match","dataArray","infoObject","slice","tempEuler","tempVec","lTranslationM","lPreRotationM","lRotationM","lPostRotationM","lScalingM","lScalingPivotM","lScalingOffsetM","lRotationOffsetM","lRotationPivotM","lParentGX","lParentLX","lGlobalT","inheritType","lLRM","lParentGRM","lParentTM","lParentGRSM","lParentGSM","lLSM","lGlobalRS","lParentLSM_inv","lParentGSM_noLocal","lRotationPivotM_inv","lScalingPivotM_inv","lTransform","lLocalTWithAllPivotAndOffsetInfo","lGlobalTranslation","enums","a1","a2","useFBX","useLoader","input","useAnimations","clips","root","ref","React.useRef","actualRef","React.useState","mixer","AnimationMixer","React.useLayoutEffect","lazyActions","api","React.useMemo","actions","useFrame","state","delta","React.useEffect","currentRoot","action","ExperienceCanvas","animationName","group","useRef","scene","nodes","useGLTF","idleAnimation","saluteAnimation","clappingAnimation","victoryAnimation","useEffect","isSmall","useMediaQuery","isMobile","isTablet","isExtraLarge","calculateSizes","scale","positionY","jsxs","jsx"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}